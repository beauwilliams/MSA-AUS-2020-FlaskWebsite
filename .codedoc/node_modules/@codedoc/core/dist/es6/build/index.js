var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import chalk from 'chalk';
import { join } from 'path';
import { sequentially, handleError } from 'rxline';
import { readFile, mapExt, mapRoot } from 'rxline/fs';
import { post, save } from '@connectv/sdh';
import { files } from './files';
import { initJss } from '../transport/setup-jss';
import { bundle } from './bundle';
import { content } from './content';
import { styles } from './styles';
import { loadToC } from './toc';
import { namespace } from './namespace';
import { pageSpecificMeta } from '../components/page/meta-override/post';
export function build(config, builder, themeInstaller, webpackConfig) {
    return __awaiter(this, void 0, void 0, function* () {
        initJss();
        const _bundle = bundle(config, themeInstaller);
        const _styles = styles(config);
        const _toc = yield loadToC(config);
        const source = files(config);
        return new Promise((resolve, reject) => {
            source
                .peek(file => console.log(`${chalk.gray('# building ........ ' + join(file.root, file.path))}`))
                .pipe(readFile(), content(builder, _toc, config, _styles), post(_bundle.collect()), post(namespace(config)), post(pageSpecificMeta), (file) => {
                (config.page.post || []).forEach(p => file.content.post(html => p(html, file, config)));
                return file;
            }, mapExt(() => '.html'), mapRoot(() => config.dest.html), save())
                .pipe(handleError((err, file, rethrow) => {
                rethrow(new Error(chalk `{redBright # ERROR} in {underline ${file.path}}\n${(err === null || err === void 0 ? void 0 : err.message) || err}`));
            }))
                .peek(file => console.log(`${chalk.green('#')}${chalk.gray(' built:: .........')} ${join(file.root, file.path)}`))
                .process()
                .collect(sequentially, (built) => __awaiter(this, void 0, void 0, function* () {
                console.log(`${chalk.gray('# building ........ ' + _styles.path)}`);
                yield _styles.save();
                console.log(`${chalk.green('#')} ${chalk.gray('built:: .........')} ${_styles.path}`);
                console.log(`${chalk.gray('# building ........ ' + _bundle.path)}`);
                yield save(_bundle, webpackConfig);
                _bundle.repack = false;
                console.log(`${chalk.green('#')} ${chalk.gray('built:: .........')} ${_bundle.path}`);
                if (config.afterBuild) {
                    console.log(chalk.gray('# running after build hooks ...'));
                    for (let hook of config.afterBuild) {
                        console.log(chalk.gray('# running ......... ' + hook.name + '()'));
                        yield hook({ config, built, source, partial: false });
                        console.log(`${chalk.green('#')} ${chalk.gray('finished:: ......')} ${hook.name}()`);
                    }
                }
                resolve({ bundle: _bundle, styles: _styles, toc: _toc });
            }), reject);
        });
    });
}
//# sourceMappingURL=index.js.map