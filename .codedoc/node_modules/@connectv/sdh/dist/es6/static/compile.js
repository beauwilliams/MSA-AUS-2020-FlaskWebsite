var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { JSDOM } from 'jsdom';
const registerGlobalDom = require('jsdom-global');
import { StaticRenderer } from './renderer';
import { Compiled } from './compiled';
import { itsRendered } from '../shared/lifecycle';
import { isPostProcessPlugin } from './types';
function _render(el, target, renderer) {
    if (!el)
        return;
    let nodes = [];
    if (el instanceof HTMLElement)
        el.childNodes.forEach(n => nodes.push(n));
    else if (el instanceof Node)
        return;
    else
        nodes = el;
    nodes.forEach(n => renderer.render(n).on(target));
}
function _copy_attrs(el, target) {
    if (!el || !(el instanceof HTMLElement))
        return;
    for (let i = 0; i < el.attributes.length; i++) {
        const attr = el.attributes.item(i);
        if (attr)
            target.setAttribute(attr.name, attr.value);
    }
}
/**
 *
 * Will create a `Compiled` object from given render function. A render function
 * is any function that returns an HTML Node (or a promise of one), given the proper
 * renderer and document objects.
 *
 * It will also apply any post processors to the `Compiled` object from plugins
 * that are `PostProcessPlugins`, allowing given renderer plugins to do some post processing
 * on the final document.
 *
 * @param render the render function
 * @param plugins a list of renderer plugins to be attached to the renderer
 *
 */
export function compile(render, ...plugins) {
    try {
        document;
    }
    catch (_) {
        registerGlobalDom();
    }
    const dom = new JSDOM('<!DOCTYPE html>');
    const renderer = new StaticRenderer().plug(...plugins);
    const compiled = new Compiled(dom, (() => __awaiter(this, void 0, void 0, function* () {
        const node = yield render(renderer, dom.window.document);
        if (node instanceof HTMLHtmlElement) {
            _render(node.firstChild, dom.window.document.head, renderer);
            _render(node.lastChild, dom.window.document.body, renderer);
            _copy_attrs(node.lastChild, dom.window.document.body);
        }
        else if (node instanceof HTMLHeadElement) {
            _render(node, dom.window.document.head, renderer);
        }
        else if (node instanceof HTMLBodyElement) {
            _render(node, dom.window.document.body, renderer);
            _copy_attrs(node, dom.window.document.body);
        }
        else {
            _render([node], dom.window.document.body, renderer);
        }
        itsRendered(dom.window.document);
    }))());
    renderer.plugins.filter(isPostProcessPlugin).forEach(plugin => compiled.post(doc => plugin.post(doc)));
    return compiled;
}
//# sourceMappingURL=compile.js.map