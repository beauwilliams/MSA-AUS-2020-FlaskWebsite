{"version":3,"file":"build.js","sourceRoot":"","sources":["../../../src/static/build.ts"],"names":[],"mappings":";;;;;;;;;AAKA,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AAuDpC,MAAM,UAAU,KAAK,CAAI,OAAqB,EACtB,GAAG,OAAgD;IAEzE,IAAI,aAAmC,CAAC;IACxC,IAAI,OAAO,IAAI,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE;QACjC,aAAa,GAAG,CAAC,CAAU,EAAE,EAAE,CAC7B,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,OAAO,CAAC,KAAK,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;KAC1D;IAED,OAAO,UAAS,CAAU;QACxB,MAAM,OAAO,GAAG,aAAa,CAAC,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;QACtD,uCACK,CAAC,KACJ,OAAO,EAAE,OAAO,CAAC,CAAC,QAAQ,EAAE,QAAQ,EAAE,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC,OAAO,EAAE,QAAQ,EAAE,CAAC,EAAE,QAAQ,CAAC,EAAE,GAAG,OAAO,CAAC,IAC/F;IACJ,CAAC,CAAA;AACH,CAAC;AAGD;;;;;;;;GAQG;AACH,MAAM,UAAU,IAAI,CAAC,SAAwB;IAC3C,OAAO,UAAS,CAAiB;QAC/B,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QAC1B,OAAO,CAAC,CAAC;IACX,CAAC,CAAA;AACH,CAAC;AAGD;;;;;GAKG;AACH,MAAM,UAAU,SAAS;IACvB,OAAO,UAAe,CAAiB;;YACrC,uCACK,CAAC,KACJ,OAAO,EAAE,MAAM,CAAC,CAAC,OAAO,CAAC,SAAS,EAAE,IACrC;QACH,CAAC;KAAA,CAAA;AACH,CAAC;AAGD;;;;;;GAMG;AACH,MAAM,UAAU,gBAAgB;IAC9B,OAAO,UAAe,CAAiB;;YACrC,OAAO,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC;QACxC,CAAC;KAAA,CAAA;AACH,CAAC","sourcesContent":["import { File } from 'rxline/fs';\nimport { Function } from 'rxline';\n\nimport { Compiled, PostProcessor } from './compiled';\nimport { StaticRenderer } from './renderer';\nimport { compile } from './compile';\nimport { Plugin } from '@connectv/html';\n\n\n/**\n * \n * Denotes a function that builds an HTML document (or Node) based on some other\n * input.\n * \n */\nexport type BuildFunc<T> = (t: T, renderer: StaticRenderer, file: File<T>, document: Document) => Node | Promise<Node>;\n\n/**\n * \n * Denotes a function that builds a renderer plugin based on given file. The plugin will be plugged\n * into the renderer that is subsequently used to render an HTML document from the file content.\n * \n */\nexport type PluginBuilder<T, R=any, Tag=any> = (f: File<T>) => Plugin<R, Tag>;\n\n/**\n * \n * Denotes a function that creates a list of renderer plugins based on given file. These plugins\n * will be plugged into the renderer that is subsequently used to render an HTML document from the\n * file content.\n * \n */\nexport type PluginListBuilder<T, R=any, Tag=any> = (f: File<T>) => Plugin<R, Tag>[];\n\n/**\n * \n * Convenience function for rxline files. Returns a transform that converts the content \n * of an rxline `File<T>` using the given `BuildFunc<T>` to a file whose content \n * is a compiled document.\n * \n * @param builder\n * \n */\nexport function build<T>(builder: BuildFunc<T>): Function<File<T>, File<Compiled>>;\n\n\n/**\n * \n * Convenience function for rxline files. Returns a transform that converts the content \n * of an rxline `File<T>` using the given `BuildFunc<T>` to a file whose content \n * is a compiled document. Uses provided plugins or `PluginBuilder`s to create plugins\n * that are to be plugged in the renderer to be used.\n * \n * @param builder\n * @param plugins\n * \n */\nexport function build<T>(builder: BuildFunc<T>, ...plugins: (PluginBuilder<T> | Plugin<any, any>)[]):\n  Function<File<T>, File<Compiled>>;\n\nexport function build<T>(builder: BuildFunc<T>, \n                        ...plugins: (PluginBuilder<T> | Plugin<any, any>)[]\n  ): Function<File<T>, File<Compiled>> {\n  let pluginBuilder: PluginListBuilder<T>;\n  if (plugins && plugins.length > 0) {\n    pluginBuilder = (f: File<T>) => \n      plugins.map(p => (typeof p === 'function') ? p(f) : p);\n  }\n\n  return function(f: File<T>) {\n    const plugins = pluginBuilder ? pluginBuilder(f) : [];\n    return {\n      ...f,\n      content: compile((renderer, document) => builder(f.content, renderer, f, document), ...plugins)\n    };\n  }\n}\n\n\n/**\n * \n * Convenience function for rxline files. Returns a transform that queues the \n * given `PostProcessor` function to be applied on contents of given file, \n * assuming the contents are some compiled document model.\n * \n * @param processor\n * \n */\nexport function post(processor: PostProcessor): Function<File<Compiled>, File<Compiled>> {\n  return function(f: File<Compiled>) {\n    f.content.post(processor);\n    return f;\n  }\n}\n\n\n/**\n * \n * Convenience function for rxline files. Returns a transform that serializes\n * contents of given file, assuming the contents are some compiled document model.\n * \n */\nexport function serialize(): Function<File<Compiled>, File<string>> {\n  return async function(f: File<Compiled>) {\n    return {\n      ...f,\n      content: await f.content.serialize()\n    }\n  }\n}\n\n\n/**\n * \n * Convenience function for rxline files. Returns a transform that\n * saves the contents of the given file, assuming the contents are some\n * compiled document model, to the address of the file itself.\n * \n */\nexport function saveCompiledFile(): Function<File<Compiled>, File<string>> {\n  return async function(f: File<Compiled>) {\n    return f.content.save(f.path, f.root);\n  }\n}\n"]}