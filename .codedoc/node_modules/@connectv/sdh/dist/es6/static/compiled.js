var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { writeFile } from 'rxline/fs';
import { isReady } from '../shared/lifecycle';
/**
 *
 * Represents a compiled HTML Document. A compiled HTML Document is one
 * whose structure is determined (typically via some render function),
 * perhaps should wait on some data (denoted by some promises),
 * and then can be rendered either to a string or to a file.
 *
 */
export class Compiled {
    /**
     *
     * @param dom   the document model object
     * @param ready a general promise to wait for before this compiled document can be
     *              serialized / saved to a file. This is typically used to render all necessary
     *              DOM structure to the given document model object.
     *
     */
    constructor(dom, ready) {
        this.dom = dom;
        this.ready = ready;
        this._postProcessors = [];
    }
    /**
     *
     * @returns `true` when the document model is fully rendered and all necessary data
     *           are also fetched. DOES NOT RETURN FALSE, waits for readiness of the document
     *           instead. also runs all post processing passed via `.post()` method.
     *
     * @note this method is idempotent, i.e. it will construct one singular promise
     *       and will return that promise on subsequent calls.
     *
     */
    isReady() {
        if (!this._readyPromise) {
            this._readyPromise = (() => __awaiter(this, void 0, void 0, function* () {
                yield this.ready;
                yield isReady(this.dom.window.document.head);
                yield isReady(this.dom.window.document.body);
                for (let processor of this._postProcessors) {
                    yield processor(this.dom.window.document);
                }
                return true;
            }))();
        }
        return this._readyPromise;
    }
    /**
     *
     * @returns a string representation of the compiled document model.
     *
     */
    serialize() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.isReady();
            return this.dom.serialize();
        });
    }
    /**
     *
     * saves the compiled document model to a file at given path (and given root).
     *
     * @param path the path of the saved file
     * @param root the root of the saved file
     * @returns a `rxline.File<string>` object representing stored string content and file address.
     *
     */
    save(path, root) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.isReady();
            return writeFile()({ path, root: root || '', content: this.dom.serialize() });
        });
    }
    /**
     *
     * queues up given post processor. the processor will be executed
     * on the document model after it finishes compilation and all of its
     * required data are ready.
     *
     * @param processor
     * @returns `this` for chaining convenience.
     *
     */
    post(processor) {
        this._postProcessors.push(processor);
        return this;
    }
}
//# sourceMappingURL=compiled.js.map