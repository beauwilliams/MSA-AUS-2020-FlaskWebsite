{"version":3,"file":"meta.js","sourceRoot":"","sources":["../../../src/dynamic/meta.ts"],"names":[],"mappings":";;;;;;;;;AAAA,OAAO,EAAE,KAAK,EAAE,IAAI,EAAE,MAAM,MAAM,CAAC;AACnC,OAAO,EAAE,SAAS,EAAE,QAAQ,EAAE,MAAM,WAAW,CAAC;AAGhD,OAAO,EAAiB,QAAQ,EAAE,MAAM,4BAA4B,CAAC;AAgCrE;;;;;;;;;GASG;AACH,MAAM,UAAU,QAAQ,CAAC,MAAc;IACrC,MAAM,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IACzC,OAAO,IAAI,CAAC,GAAG,EAAE,IAAI,GAAG,YAAY,CAAC,CAAC;AACxC,CAAC;AAGD;;;;;;;;;GASG;AACH,MAAM,UAAU,QAAQ,CAAC,MAAc;IACrC,MAAM,IAAI,GAAe;QACvB,IAAI,EAAE,MAAM,CAAC,WAAW,CAAC,GAAG,CAAC,QAAQ,CAAC;QACtC,UAAU,EAAE,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC;KACzC,CAAC;IAEF,IAAI,MAAM,CAAC,cAAc;QACvB,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC,MAAM,CAAC,cAAc,CAAC,CAAC;IAElD,OAAO,SAAS,EAAE,CAAC;QACjB,IAAI,EAAE,QAAQ,CAAC,MAAM,CAAC;QACtB,IAAI,EAAE,EAAE;QACR,OAAO,EAAE,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,SAAS,EAAE,CAAC,CAAC;KAC5C,CAAC,CAAC;AACL,CAAC;AAGD;;;;;;;GAOG;AACH,MAAM,UAAgB,QAAQ,CAAC,MAAc;;QAC3C,OAAO,IAAI,CAAC,KAAK,CAAC,CAAC,MAAM,QAAQ,EAAE,CAAC;YAChC,IAAI,EAAE,QAAQ,CAAC,MAAM,CAAC;YACtB,IAAI,EAAE,EAAE;YACR,OAAO,EAAE,SAAS;SACnB,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC;IACjB,CAAC;CAAA","sourcesContent":["import { parse, join } from 'path';\nimport { writeFile, readFile } from 'rxline/fs';\n\nimport { Bundle } from './bundle';\nimport { TransportInfo, leanInfo } from './transport/transport-info';\n\n\n/**\n *\n * Denotes the metadata of a bundle\n *\n */\nexport interface BundleMeta {\n  /**\n   * \n   * The renderer used for the bundle's components.\n   * \n   */\n  renderer?: TransportInfo,\n\n  /**\n   * \n   * Init scripts that will execute upon bundle being loaded in client-side.\n   * \n   */\n  init: TransportInfo[],\n\n  /**\n   * \n   * Components included in the bundle.\n   * \n   */\n  components: TransportInfo[],\n}\n\n\n/**\n *\n * @param bundle\n * @returns the standard address of the meta file for given bundle.\n * @note that the address might not correspond to an actual file on the filesystem. This\n * can happen if the bundle has never been saved to the filesystem with its current path,\n * storing its meta data was omitted from its saving process, or the metadata file was lost\n * afterwards.\n *\n */\nexport function metafile(bundle: Bundle) {\n  const { dir, name } = parse(bundle.path);\n  return join(dir, name + '.meta.json');\n}\n\n\n/**\n *\n * Saves the meta data of given bundle to filesystem. This meta data contains\n * info about which transport components does the bundle contain and is useful\n * for subsequent reloading the bundle from filesystem.\n *\n * @param bundle\n * @returns a `rxline` file corresponding to the stored meta data file.\n *\n */\nexport function saveMeta(bundle: Bundle) {\n  const meta: BundleMeta = {\n    init: bundle.initImports.map(leanInfo),\n    components: bundle.imports.map(leanInfo),\n  };\n\n  if (bundle.rendererImport)\n    meta.renderer = leanInfo(bundle.rendererImport);\n\n  return writeFile()({\n    path: metafile(bundle),\n    root: '',\n    content: JSON.stringify(meta, undefined, 2)\n  });\n}\n\n\n/**\n *\n * @param bundle \n * @returns the stored metadata of the given bundle.\n * @throws if the metadata file cannot be found.\n * @see metafile()\n *\n */\nexport async function loadMeta(bundle: Bundle): Promise<BundleMeta> {\n  return JSON.parse((await readFile()({\n      path: metafile(bundle),\n      root: '',\n      content: undefined\n    })).content);\n}\n"]}