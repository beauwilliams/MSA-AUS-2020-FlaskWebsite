{"version":3,"file":"transport-info.js","sourceRoot":"","sources":["../../../../src/dynamic/transport/transport-info.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,GAAG,EAAE,MAAM,MAAM,CAAC;AAC3B,OAAO,EAAE,UAAU,EAAE,MAAM,QAAQ,CAAC;AACpC,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AA0CrD,SAAS,IAAI,CAAC,CAAS;IACrB,OAAO,UAAU,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,QAAQ,EAAE,CAAC;AACjE,CAAC;AAGD;;;;;;GAMG;AACH,MAAM,UAAU,UAAU,CAAC,IAAY,EAAE,KAAsB;IAC7D,MAAM,QAAQ,GAAG,CAAC,KAAK,CAAC,WAAW,EAAE,IAAI,EAAE,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IAClE,OAAO,EAAE,IAAI,EAAE,QAAQ,EAAE,IAAI,EAAE,IAAI,CAAC,QAAQ,GAAG,IAAI,GAAG,IAAI,CAAC,EAAE,QAAQ,EAAE,KAAK,EAAE,CAAC;AACjF,CAAC;AAGD;;;;;;;GAOG;AACH,MAAM,UAAU,UAAU,CAAC,IAAU,EAAE,IAAmB;IACxD,IAAI,IAAI,YAAY,gBAAgB;QAClC,UAAU,CAAC,WAAW,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC,CAAC;;QAEnC,IAAY,CAAC,gBAAgB,GAAG,IAAI,CAAC;AAC1C,CAAC;AAGD;;;;;GAKG;AACH,MAAM,UAAU,SAAS,CAAC,IAAU;IAClC,IAAI,IAAI,YAAY,gBAAgB;QAAE,OAAO,SAAS,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,CAAC;SACrE;QACH,IAAI,GAAG,GAAoB,EAAE,CAAC;QAE9B,MAAM,IAAI,GAAI,IAAY,CAAC,gBAAgB,CAAC;QAC5C,IAAI,IAAI;YAAE,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACzB,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC,GAAG,GAAG,GAAG,CAAC,MAAM,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;QAErE,OAAO,GAAG,CAAC;KACZ;AACH,CAAC;AAGD;;;;;GAKG;AACH,MAAM,UAAU,QAAQ,CAAC,IAAmB;IAC1C,OAAO;QACL,IAAI,EAAE,IAAI,CAAC,IAAI;QACf,QAAQ,EAAE,IAAI,CAAC,QAAQ;QACvB,IAAI,EAAE,IAAI,CAAC,IAAI;KAChB,CAAA;AACH,CAAC","sourcesContent":["import { sep } from 'path';\nimport { createHash } from 'crypto';\nimport { getLSMarker } from '../../shared/lifecycle';\n\n\n/**\n *\n * Denotes necessary server-side import information\n * for transporting some code to the client.\n *\n */\nexport interface TransportInfo {\n  /**\n   *\n   * Name of the artifact to be imported.\n   *\n   */\n  name: string;\n\n  /**\n   *\n   * The file from which the artifact is to be imported from.\n   *\n   */\n  filename: string;\n\n  /**\n   *\n   * A hash for identifying the transported artifact without leaking\n   * server filesystem information to the client side.\n   *\n   */\n  hash: string;\n\n  /**\n   *\n   * Whether or not this particular dependency is yet resolved by any\n   * bundle.\n   *\n   */\n  resolved?: boolean,\n}\n\n\nfunction hash(x: string) {\n  return createHash('md5').update(x).digest('base64').toString();\n}\n\n\n/**\n *\n * @param name\n * @param trace\n * @returns a `TransportInfo` based on given artifact name and given NodeJS trace.\n *\n */\nexport function createInfo(name: string, trace: NodeJS.CallSite): TransportInfo {\n  const filename = (trace.getFileName() || '').split(sep).join('/');\n  return { name, filename, hash: hash(filename + '::' + name), resolved: false };\n}\n\n\n/**\n *\n * Attaches given `TransportInfo` to given `Node`.\n *\n * @param node\n * @param info\n *\n */\nexport function attachInfo(node: Node, info: TransportInfo) {\n  if (node instanceof DocumentFragment)\n    attachInfo(getLSMarker(node), info);\n  else\n    (node as any).__transport_info = info;\n}\n\n\n/**\n *\n * @param node\n * @returns all attached `TransportInfo` on given `Node`\n *\n */\nexport function fetchInfo(node: Node): TransportInfo[] {\n  if (node instanceof DocumentFragment) return fetchInfo(getLSMarker(node));\n  else {\n    let res: TransportInfo[] = [];\n\n    const info = (node as any).__transport_info;\n    if (info) res.push(info);\n    node.childNodes.forEach(child => res = res.concat(fetchInfo(child)));\n\n    return res;\n  }\n}\n\n\n/**\n *\n * @param info\n * @returns a lean version of the transport info, omitting runtime-data.\n *\n */\nexport function leanInfo(info: TransportInfo): TransportInfo {\n  return {\n    name: info.name,\n    filename: info.filename,\n    hash: info.hash\n  }\n}\n"]}