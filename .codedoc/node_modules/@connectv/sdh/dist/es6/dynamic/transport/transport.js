var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { autoId } from '@connectv/html';
import { callTrace } from '../../shared/trace';
import { recipientPromise } from '../../static/promise/recipient-promise';
import { createInfo, attachInfo } from './transport-info';
/**
 *
 * @param component
 * @returns all attached `TransportInfo` on the given component, if any.
 *
 */
export function getCompTransportInfo(component) {
    return component.__transport_info;
}
/**
 *
 * Attaches given `TransportInfo` on given component.
 *
 * @param component
 * @param info
 *
 */
export function attachCompTransportInfo(component, info) {
    component.__transport_info = Object.assign(Object.assign({}, info), { resolved: false });
}
/**
 *
 * Creates a _transport reference_. A _transport reference_ can be used to conduct
 * **broad transport**, i.e. you can have the content that is supposed to be rendered
 * on the client side also replace some server-side-rendered content:
 *
 * ```tsx
 * function myComp(_, renderer) {
 *   const tr = transportRef();
 *
 *   return <fragment>
 *     <StaticComponent _transport={tr}/>       // --> rendered on server-side
 *     <div data-transport={tr}/>               // --> rendered on server-side
 *     <TransportComponent _transport={tr}/>    // --> rendered on client-side, replaces the others.
 *   </fragment>
 * }
 * ```
 *
 * @returns a _transport reference_
 *
 *
 */
export function transportRef() { return autoId(); }
/**
 *
 * Creates a transport component based on given (original) component.
 * On the server-side, the transport component ensures _CLIENT-SIDE_ rendering
 * of original component on the same spot in the DOM tree with same properties.
 * On the client-side, the transport component is identical to the original component.
 *
 * example:
 *
 * ```tsx
 * import { state } from '@connectv/core';
 * import { transport } from '@connectv/sdh/transport';
 *
 * export function Counter(_, renderer) {
 *   const count = state(0);
 *   return <div onclick={() => count.value++}>You clicked {count} times!</div>;
 * }
 *
 * export const $Counter = transport(Counter);
 * ```
 *
 * In this example, you cannot use `Counter` component on server-side rendering since it needs
 * to bind to user clicks (trying to render it actually results in an error). However, you can
 * utilize `$Counter` instead, and it will ensure that `Counter` is rendered on the same locations
 * on the DOM tree that you rendered `$Counter` on, on the client-side.
 *
 * @note You MUST export both the original component and the transport component, from the same file.
 * This is how the original component is then imported (alongside with any possible dependencies)
 * into client bundles.
 *
 * @note Any properties passed to the transport component will be used in rendering of the original
 * component. However, you CANNOT pass any child elements to the transport component.
 *
 */
export function transport(component) {
    const trace = callTrace();
    if (!trace)
        return component; // --> unable to get trace info, perhaps running on client.
    const info = createInfo(component.name, trace);
    const comp = function (props, renderer) {
        const id = props._transport || transportRef();
        const script = renderer.create("script", { id: id },
            "(function()",
            '{',
            "function load()",
            '{',
            "if (window.__sdh_transport)",
            '{',
            "window.__sdh_transport(\"",
            id,
            "\", \"",
            info.hash,
            "\", ",
            Promise.all(Object.keys(props).filter(key => key !== '_transport').map((key) => __awaiter(this, void 0, void 0, function* () { return [key, yield this.expose.in(key, recipientPromise())]; })))
                .then(entries => entries.reduce((obj, [key, value]) => {
                obj[key] = value;
                return obj;
            }, {}))
                .then(JSON.stringify),
            ");",
            props._transport ?
                `document.querySelectorAll('[data-transport="${props._transport}"]').forEach(function(node){node.remove()});`
                : '',
            "} }; if (document.readyState == 'complete') load(); else window.addEventListener('load', load); })()");
        attachInfo(script, info);
        return script;
    };
    attachCompTransportInfo(comp, info);
    return comp;
}
//# sourceMappingURL=transport.js.map