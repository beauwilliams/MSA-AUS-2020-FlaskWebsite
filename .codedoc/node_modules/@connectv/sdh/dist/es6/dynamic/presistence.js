var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Bundle } from './bundle';
import { pack } from './pack';
import { saveMeta, loadMeta } from './meta';
/**
 *
 * Packs and stores given bundle on the file system.
 * Also stores corresponding metadata alongside the bundle.
 *
 * For using your custom programmatic bundler instead of webpack,
 * you can do the following:
 *
 * ```typescript
 * async function mySaveBundle(bundle: Bundle) {
 *   await packWith(myPackFunc)(bundle);
 *   await saveMeta(bundle);
 * }
 * ```
 *
 * @param bundle
 * @param config web-pack configuration override
 * @returns the given bundle after the process is finished.
 *
 */
export function saveBundle(bundle, config) {
    return __awaiter(this, void 0, void 0, function* () {
        yield pack(bundle, config);
        yield saveMeta(bundle);
        return bundle;
    });
}
/**
 *
 * Will load a previously constructed and stored bundle from filesystem.
 *
 * @param path the path to load the bundle from.
 * @param url  the URL that the bundle is to be accessible by clients.
 * @returns the `Bundle` object
 * @throws if the bundle meta data cannot be located.
 *
 */
export function loadBundle(path, url) {
    return __awaiter(this, void 0, void 0, function* () {
        const bundle = new Bundle(url || path, path);
        const meta = yield loadMeta(bundle);
        bundle.imports = meta.components;
        bundle.rendererImport = meta.renderer;
        bundle.initImports = meta.init;
        bundle.repack = false;
        return bundle;
    });
}
//# sourceMappingURL=presistence.js.map