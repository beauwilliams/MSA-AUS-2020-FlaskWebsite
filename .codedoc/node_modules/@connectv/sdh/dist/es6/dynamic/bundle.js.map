{"version":3,"file":"bundle.js","sourceRoot":"","sources":["../../../src/dynamic/bundle.tsx"],"names":[],"mappings":"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","sourcesContent":["import { CompType, RendererLike } from '@connectv/html';\n\nimport { StaticRenderer } from '../static';\n\nimport { TransportInfo, fetchInfo } from './transport/transport-info';\nimport { getCompTransportInfo } from './transport/transport';\nimport { TransportedFunc, getFuncTransportInfo } from './transport/func-transport';\n\n\n/**\n *\n * Denotes different bundle processing modes. A bundle processing mode\n * determines how a bundle reacts to transport dependencies of given\n * `HTMLDocument`:\n *\n */\nexport enum ProcessingMode { \n  /**\n   *\n   * In this mode, unresolved dependencies of the document are checked.\n   * If they appear in the bundle, they are marked as resolved, and the bundle\n   * will be added to the header of the document.\n   *\n   */\n  ResolveOnly,\n\n  /**\n   *\n   * In this mode, unresolved dependencies of the document are checked,\n   * if they appear in the bundle, they are marked as resolved, otherwise\n   * they will be added to the bundle, and the bundle added to the header\n   * of the document. Processing in this mode might require the bundle\n   * to be reconstructed.\n   *\n   */\n  ResolveAndCollect \n}\n\n\n/**\n *\n * Represents a bundle containing bundled code for components that need to be \n * transported and executed on client side. A bundle is mainly denoted\n * by the URL it will be accessible on (from client's perspective) and the\n * server-side imports necessary to construct/reconstruct it.\n *\n */\nexport class Bundle {\n  /**\n   *\n   * List of all server-side imports necessary to construct/reconstruct this bundle.\n   *\n   */\n  imports: TransportInfo[];\n\n  /**\n   * \n   * _Optional_, the custom renderer factory import in case the bundle is to use\n   * a custom client-side renderer for rendering transport components.\n   * \n   */\n  rendererImport: TransportInfo | undefined;\n\n  /**\n   * \n   * _Optional_, the custom init scripts to be executed when the bundle\n   * is loaded in the client-side.\n   * \n   */\n  initImports: TransportInfo[];\n\n  /**\n   *\n   * The path of the file the bundle is stored on (or is to be stored on).\n   * If not provided, will be the same as `.url`.\n   *\n   */\n  path: string;\n\n  /**\n   *\n   * Whether the bundle should be reconstructed or not.\n   *\n   */\n  repack: boolean = true;\n\n  /**\n   *\n   * @param url  the URL on which the bundle will be accessible to clients.\n   * @param path the path of the file the bundle is stored on. defaults to the URL.\n   *\n   */\n  constructor(readonly url: string, path?: string) {\n    this.imports = [];\n    this.initImports = [];\n    this.path = path || this.url;\n  }\n\n  /**\n   *\n   * @param info \n   * @returns `true` if the bundle includes given server-side import.\n   *\n   */\n  includes(info: TransportInfo) { return this.imports.some(i => i === info || i.hash === info.hash); }\n\n  /**\n   * \n   * @param info a new server-side import to be added to this bundle.\n   * @returns `this` for chaining convenience.\n   * @warning This function DOES NOT check whether given import is already part of the bundle or not.\n   * Avoid using it directly unless you know what you are doing.\n   *\n   */\n  add(info: TransportInfo) {\n    this.imports.push(info);\n    this.repack = true;\n    return this;\n  }\n\n  /**\n   * \n   * @returns a `PostProcessor` that processes given `HTMLDocument` in `ResolveAndCollect` mode.\n   * This means that unresolved dependencies of given document will be checked, if they are part of the\n   * bundle they will be marked as resolved, and if not, they will be added to the bundle (in which\n   * case the bundle needs to be reconstructed). In both cases, the bundle will be added\n   * to the document's header (via a `<script/>` tag with the bundle's URL).\n   * \n   */\n  collect(): (document: HTMLDocument) => void;\n\n  /**\n   *\n   * Adds necessary server-side imports for given transport components to this bundle.\n   * Components passed to this function MUST BE transport components, i.e. generated\n   * using `transport()` method.\n   *\n   * @returns `this` for chaining convenience.\n   * @see transport()\n   *\n   */\n  collect(comp: CompType<any, any>, ...rest: CompType<any, any>[]): this;\n  collect(...comps: CompType<any, any>[]) {\n    comps.forEach(comp => {\n      const info = getCompTransportInfo(comp);\n      if (info && !this.includes(info)) this.add(info);\n    });\n\n    return comps.length == 0 ? this.process(ProcessingMode.ResolveAndCollect) : this;\n  }\n\n  /**\n   *\n   * @returns a `PostProcessor` that processes given `HTMLDocument` in `ResolveOnly` mode.\n   * This means that unresolved dependencies of the given document will be checked, if they\n   * are part of the bundle they will be marked as resolved and the bundle will be added to the\n   * document's header (via a `<script/>` tag with the bundle's URL).\n   *\n   */\n  resolve() { return this.process(ProcessingMode.ResolveOnly); }\n\n  /**\n   *\n   * @param mode \n   * @returns a `PostProcessor` that processes given `HTMLDocument` using given mode.\n   * @see Bundle.resolve()\n   * @see Bundle.collect()\n   *\n   */\n  process(mode: ProcessingMode) {\n    const renderer = new StaticRenderer();\n    return (document: HTMLDocument) => {\n      let used = false;\n      fetchInfo(document).forEach(info => {\n        if (!info.resolved) {\n          if (this.includes(info)) info.resolved = used = true;\n          else if (mode === ProcessingMode.ResolveAndCollect) {\n            this.add(info);\n            info.resolved = used = true;\n          }\n        }\n      });\n\n      if (used || this.initImports.length > 0)\n        renderer.render(<script async defer src={this.url}/>).on(document.head);\n    }\n  }\n\n  /**\n   *\n   * Will set the client-side renderer used by the bundle to given\n   * renderer factory. Useful for using custom client-side renderers.\n   *\n   * @param factory the factory function to be transported. MUST BE result of `funcTransport()` function.\n   * @returns `this` for chaining convenience.\n   *\n   */\n  withRenderer<R, T>(factory: TransportedFunc<RendererLike<R, T>>) {\n    const _rendererImport = getFuncTransportInfo(factory);\n    if (_rendererImport) {\n      if (!this.rendererImport || this.rendererImport && this.rendererImport.hash !== _rendererImport.hash) {\n        this.rendererImport = _rendererImport;\n        this.repack = true;\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   *\n   * Will add the given init-function to initialization functions of this bundle.\n   * These functions will be executed when the bundle is loaded on the client-side.\n   *\n   * @param initFunc the initialization function to be transported. MUST BE result of `funcTransport()` function.\n   * @returns `this` for chaining convenience.\n   *\n   */\n  init(initFunc: TransportedFunc<void>) {\n    const _import = getFuncTransportInfo(initFunc);\n    if (!this.initImports.some(i => i.hash === _import.hash)) {\n      this.initImports.push(_import);\n      this.repack = true;\n    }\n\n    return this;\n  }\n}\n"]}