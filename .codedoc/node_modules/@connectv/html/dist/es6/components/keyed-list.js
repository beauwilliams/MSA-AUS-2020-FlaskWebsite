import { State, SimpleDeep, KeyedDeep, sink, isPinLike, wrap } from '@connectv/core';
import { Marker } from './marker';
import { scanRemove } from './util/scan';
export function KeyedList(props, renderer) {
    let startMark = renderer.create(Marker, null);
    this.track.mark(startMark);
    let markers = [];
    let list;
    if (props.of instanceof KeyedDeep)
        list = props.of;
    else {
        let _props = props;
        if (_props.of instanceof State)
            list = new KeyedDeep(_props.of, _props.key);
        else if (_props.of instanceof SimpleDeep)
            list = new KeyedDeep(_props.of.state, _props.key);
        else {
            list = new KeyedDeep(new State([]), _props.key);
            if (isPinLike(_props.of))
                _props.of.to(list);
            else
                wrap(_props.of).to(list);
            this.track(list);
        }
    }
    this.track({
        bind() {
            (list.value || []).forEach((entry) => {
                const key = list.keyfunc(entry);
                const prevMarker = markers[markers.length - 1] || startMark;
                const marker = renderer.create(Marker, null);
                markers.push(marker);
                renderer.render(renderer.create("fragment", null,
                    props.each(list.key(key), list.index(key)),
                    marker)).after(prevMarker);
            });
        }
    });
    this.track(list.changes.to(sink((changes) => {
        if (changes.initial)
            return; // --> ignore the initial change
        const len = list.value.length;
        // STEP 1: create extra markers if need be
        if (len > markers.length) {
            for (let i = markers.length; i < len; i++) {
                let marker = renderer.create(Marker, null);
                renderer.render(marker).after(markers[i - 1] || startMark);
                markers.push(marker);
            }
        }
        // STEP 2: remove deletions (without removing their markers)
        changes.deletions.forEach(deletion => {
            let index = parseInt(deletion.index);
            let start = markers[index - 1] || startMark;
            let end = markers[index];
            scanRemove(start, end);
        });
        // STEP 3: move moved items
        let moveTargets = [];
        changes.moves.forEach(move => {
            let oldIndex = parseInt(move.oldIndex);
            let start = markers[oldIndex - 1] || startMark;
            let end = markers[oldIndex];
            moveTargets.push({ index: move.newIndex, nodes: scanRemove(start, end) });
        });
        moveTargets.forEach(target => {
            renderer.render(renderer.create("fragment", null, target.nodes)).before(markers[target.index]);
        });
        // STEP 4: add additions
        changes.additions.forEach(addition => {
            let key = list.keyfunc(addition.item);
            renderer.render(props.each(list.key(key), list.index(key))).before(markers[addition.index]);
        });
        // STEP 5: remove extra markers if need be
        if (len < markers.length) {
            for (let i = len; i < markers.length; i++)
                markers[i].parentElement.removeChild(markers[i]);
            markers.length = len;
        }
    })));
    return renderer.create("fragment", null, startMark);
}
//# sourceMappingURL=keyed-list.js.map