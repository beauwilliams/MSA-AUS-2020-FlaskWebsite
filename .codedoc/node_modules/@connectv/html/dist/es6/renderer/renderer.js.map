{"version":3,"file":"renderer.js","sourceRoot":"","sources":["../../../src/renderer/renderer.ts"],"names":[],"mappings":"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","sourcesContent":["import { PropsType, isRawValue } from '../shared/types';\n\nimport { ToBeRendered, RendererLike, RenderableFunction } from './renderer-like';\n\nimport { UnsupportedTagTypeError } from './error/unsupported-tag.error';\nimport { UnsupportedPropError } from './error/unsupported-prop.error';\nimport { UnsupportedChildError } from './error/unsupported-child.error';\n\n\nexport type ChildType<Renderable> = Renderable | RawValue | Node | ChildArray<Renderable>;\nexport interface ChildArray<Renderable> extends Array<ChildType<Renderable>> {}\n\n\n/**\n *\n * Wraps DOM API so that it is compatible with JSX/TSX expected syntax, by providing\n * a JSX factory function with the necessary signature. Additionally, provides some functions\n * to make working with DOM APIs a bit easier (to read/write).\n *\n * For proper JSX/TSX compilation, a JSX factory function is required with a predetermined\n * signature. Assuming that `renderer` is an instance of `Renderer` (this class),\n * `renderer.create()` is such a factory function. So assuming that the renderer in any context\n * is always named `renderer`, configuring typescript to use `renderer.create` function as\n * its TSX factory allows for proper TSX compilation by Typescript compiler.\n *\n */\nexport class Renderer<Renderable=RawValue, Tag=string> implements RendererLike<Renderable, Tag> {\n  /**\n   *\n   * Creates an HTML `Node` based on given parameters. The signature of this function is designed\n   * so that it matches the arguments passed to it match what Typescript compiler passes to\n   * a JSX factory.\n   *\n   * @param tag       the tag of the HTML element to be created. The compiler passes a string in case of\n   *                  lowercase-leading arguments (i.e. `sometag`) and passes the object in the context of the same name\n   *                  if the first character is uppercase (i.e. `SomeTag`). The former is conventionally\n   *                  used to denote native HTML elements, while the latter is used to denote custom elements.\n   *                  Passing `fragment` as the tag will cause the renderer to create and return a `DocumentFragment`.\n   *\n   *\n   *                  **NOTE** that the base renderer class is unable to handle custom elements, and in response\n   *                  will throw an `UnsupportedTagTypeError`. Any child renderer class might also still\n   *                  be unable to handle given custom tags and throw the same error.\n   * @param props     The properties of the HTML element to be created. Must be an object whose keys denote the name\n   *                  of the property and its values the corresponding values of those properties.\n   *                  Uses {@link Renderer#setprop} method to set each property.\n   * @param children  Child elements of the HTML element to be created. Each child is appended to the created\n   *                  element using {@link Renderer#append} method.\n   * @returns {Node}  A `Node` element with given tag (or resolved final tag based on given custom-element), or\n   *                  a `DocumentFragment` in-case a fragment is passed.\n   *\n   * @see Renderer#setprop\n   * @see Renderer#append\n   *\n   */\n  public create(\n    tag: string | Tag,\n    props: PropsType<Renderable | RawValue> | undefined,\n    ...children: ChildType<Renderable>[]\n  ): Node {\n    if (typeof tag == 'string') {\n      let el: Node;\n      if (tag === 'fragment') el = document.createDocumentFragment();\n      else {\n        if (props && props.xmlns) el = document.createElementNS(`${props.xmlns}`, tag);\n        else el = document.createElement(tag);\n\n        if (props)\n          Object.entries(props).forEach(([prop, target]) => this.setprop(prop, target, el as HTMLElement));\n      }\n\n      children.forEach(child => this.append(child, el));\n      return el;\n    }\n    else {\n      throw new UnsupportedTagTypeError(tag, this);\n    }\n  }\n\n  /**\n   *\n   * Sets properties (attributes) of created node based on given properties.\n   * The base-renderer is able to handle raw values (`number | boolean | string`),\n   * and will throw an `UnsupportedPropError` if other unhandled property types\n   * are given.\n   *\n   * @param prop   the name of the property (attribute) to be set\n   * @param target the to be set for the property (attribute)\n   * @param host   the element on which the property (attribute) is to be set.\n   *\n   */\n  public setprop(prop: string, target: RawValue | Renderable, host: HTMLElement) {\n    if (isRawValue(target)) {\n      if (typeof target === 'boolean' && target)\n        host.setAttribute(prop, '');\n      else\n        host.setAttribute(prop, target.toString());\n    }\n    else {\n      throw new UnsupportedPropError(target, this);\n    }\n  }\n\n  /**\n   *\n   * Appends given child on given host `Node`. If passed an array, will append every element of it (recursively).\n   * If a raw value (`number | boolean | string`) is passed, a `TextNode` containing the string format will be appended.\n   * In case of an unsupported type, an `UnsupportedChildError` will be thrown.\n   *\n   * @param target the target to be appended.\n   * @param host   the host to which the target should be appended to.\n   *\n   */\n  public append(target: ChildType<Renderable>, host: Node) {\n    if (target instanceof Node)\n      host.appendChild(target);\n    else if (Array.isArray(target))\n      target.forEach(_ => this.append(_, host));\n    else if (isRawValue(target))\n      host.appendChild(document.createTextNode(target.toString()));\n    else {\n      throw new UnsupportedChildError(target, this);\n    }\n  }\n\n  /**\n   *\n   * Renders given `Node` on, before or after another `Node`. Usage example:\n   *\n   * ```tsx\n   * renderer.render(<Whatever/>)\n   *         .on(document.body);\n   *\n   * renderer.render(<input/>)\n   *         .before(X);\n   *\n   * renderer.render(Y)\n   *         .after(someRef.$);\n   * ```\n   *\n   * @param node the `Node` or `RenderableFunction` to be rendered\n   * @returns a `TobeRendered` object that can be used to render the given node on, before or after another `Node`.\n   *\n   */\n  public render<T extends Node>(nodeOrFactory: T | RenderableFunction<Renderable, Tag, T>): ToBeRendered<T> {\n    let node: T;\n    if (typeof nodeOrFactory === 'function') node = nodeOrFactory(this as any);\n    else node = nodeOrFactory;\n\n    return {\n      target: node,\n      on(host: Node) {\n        host.appendChild(node);\n        return node;\n      },\n      before(ref: Node) {\n        if (ref.parentNode)\n          ref.parentNode.insertBefore(node, ref);\n        return node;\n      },\n      after(ref: Node) {\n        if (ref.parentNode)\n          ref.parentNode.insertBefore(node, ref.nextSibling);\n        return node;\n      }\n    };\n  }\n}\n\n\nexport default Renderer;\n"]}