import { Bindable, Clearable, PinLike } from "@connectv/core";
import { Unsubscribable } from "rxjs";
import { PropsType } from "../../../shared/types";
import { ChildType } from "../../renderer";
import { RendererLike } from "../../renderer-like";
export declare abstract class Component<Renderable = RawValue, Tag = string> {
    protected props: PropsType<RawValue | Renderable>;
    protected children: ChildType<Renderable>[];
    private _adapter;
    static __CVH_component_class__: boolean;
    constructor(props: PropsType<RawValue | Renderable>, children: ChildType<Renderable>[], _adapter: ComponentThis);
    protected init(): void;
    bind(): void;
    clear(): void;
    protected signature(): ComponentSignature | undefined;
    abstract render(renderer: RendererLike<Renderable | RawValue, Tag | string | CompType<Renderable | RawValue, Tag>>): Node;
    protected track(sub: Unsubscribable | Bindable | Clearable): void;
}
export declare type CompClass<Renderable = RawValue, Tag = string> = {
    new (props: PropsType<RawValue | Renderable>, children: ChildType<Renderable>[], _adapter: ComponentThis): Component<Renderable, Tag>;
};
export declare type CompFunc<Renderable = RawValue, Tag = string> = (props: PropsType<RawValue | Renderable>, renderer: RendererLike<Renderable | RawValue, Tag | string | CompType<Renderable, Tag>>, children?: ChildType<Renderable>[]) => Node;
export declare type CompType<Renderable = RawValue, Tag = string> = CompClass<Renderable, Tag> | CompFunc<Renderable, Tag>;
export declare function isCompClass<Renderable, Tag>(comp: CompType<Renderable, Tag>): comp is CompClass<Renderable, Tag>;
export interface CompInSignature {
    inputs: {
        [name: string]: any;
    };
    outputs?: {
        [name: string]: any;
    };
    states?: {
        [name: string]: any;
    };
}
export interface CompOutSignature {
    inputs?: {
        [name: string]: any;
    };
    outputs: {
        [name: string]: any;
    };
    states?: {
        [name: string]: any;
    };
}
export interface CompStateSignature {
    inputs?: {
        [name: string]: any;
    };
    outputs?: {
        [name: string]: any;
    };
    states: {
        [name: string]: any;
    };
}
export declare type ComponentSignature = CompInSignature | CompOutSignature | CompStateSignature;
interface CompInputOptionsRequired {
    required: true;
    default?: never;
}
interface CompInputOptionsNotRequired<T> {
    required: false;
    default?: T;
}
export declare type CompInputOptionsSpecified<T> = CompInputOptionsNotRequired<T> | CompInputOptionsRequired;
interface CompInputOptionsNotSpecified<T> {
    default?: T;
}
export declare type CompInputOptions<T> = CompInputOptionsSpecified<T> | CompInputOptionsNotSpecified<T>;
export interface CompInputWithOptions<T> {
    inputOptions: CompInputOptions<T>;
}
export declare function isCompInputWithOptions<T>(whatever: any): whatever is CompInputWithOptions<T>;
export declare type ExposeFunction = {
    (signature: ComponentSignature): void;
    in: <T = any>(name: string, input?: T) => T;
    out: <T = any>(name: string, output?: T) => T;
    state: <T = any>(name: string, state?: T) => T;
};
export declare type TrackFunction = {
    (whatever: Bindable | Clearable): void;
    mark: (marker: Node) => void;
};
export declare type ContextFunction = <T = PinLike>(key: string, recipient?: T) => T;
export declare type ComponentThis = {
    track: TrackFunction;
    expose: ExposeFunction;
    context: ContextFunction;
};
export declare type SafeComponentThis = {
    track?: TrackFunction;
    expose?: ExposeFunction;
    context?: ContextFunction;
};
export {};
