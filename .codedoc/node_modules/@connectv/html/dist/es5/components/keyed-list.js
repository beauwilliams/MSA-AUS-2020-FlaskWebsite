"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = require("@connectv/core");
var marker_1 = require("./marker");
var scan_1 = require("./util/scan");
function KeyedList(props, renderer) {
    var startMark = renderer.create(marker_1.Marker, null);
    this.track.mark(startMark);
    var markers = [];
    var list;
    if (props.of instanceof core_1.KeyedDeep)
        list = props.of;
    else {
        var _props = props;
        if (_props.of instanceof core_1.State)
            list = new core_1.KeyedDeep(_props.of, _props.key);
        else if (_props.of instanceof core_1.SimpleDeep)
            list = new core_1.KeyedDeep(_props.of.state, _props.key);
        else {
            list = new core_1.KeyedDeep(new core_1.State([]), _props.key);
            if (core_1.isPinLike(_props.of))
                _props.of.to(list);
            else
                core_1.wrap(_props.of).to(list);
            this.track(list);
        }
    }
    this.track({
        bind: function () {
            (list.value || []).forEach(function (entry) {
                var key = list.keyfunc(entry);
                var prevMarker = markers[markers.length - 1] || startMark;
                var marker = renderer.create(marker_1.Marker, null);
                markers.push(marker);
                renderer.render(renderer.create("fragment", null,
                    props.each(list.key(key), list.index(key)),
                    marker)).after(prevMarker);
            });
        }
    });
    this.track(list.changes.to(core_1.sink(function (changes) {
        if (changes.initial)
            return; // --> ignore the initial change
        var len = list.value.length;
        // STEP 1: create extra markers if need be
        if (len > markers.length) {
            for (var i = markers.length; i < len; i++) {
                var marker = renderer.create(marker_1.Marker, null);
                renderer.render(marker).after(markers[i - 1] || startMark);
                markers.push(marker);
            }
        }
        // STEP 2: remove deletions (without removing their markers)
        changes.deletions.forEach(function (deletion) {
            var index = parseInt(deletion.index);
            var start = markers[index - 1] || startMark;
            var end = markers[index];
            scan_1.scanRemove(start, end);
        });
        // STEP 3: move moved items
        var moveTargets = [];
        changes.moves.forEach(function (move) {
            var oldIndex = parseInt(move.oldIndex);
            var start = markers[oldIndex - 1] || startMark;
            var end = markers[oldIndex];
            moveTargets.push({ index: move.newIndex, nodes: scan_1.scanRemove(start, end) });
        });
        moveTargets.forEach(function (target) {
            renderer.render(renderer.create("fragment", null, target.nodes)).before(markers[target.index]);
        });
        // STEP 4: add additions
        changes.additions.forEach(function (addition) {
            var key = list.keyfunc(addition.item);
            renderer.render(props.each(list.key(key), list.index(key))).before(markers[addition.index]);
        });
        // STEP 5: remove extra markers if need be
        if (len < markers.length) {
            for (var i = len; i < markers.length; i++)
                markers[i].parentElement.removeChild(markers[i]);
            markers.length = len;
        }
    })));
    return renderer.create("fragment", null, startMark);
}
exports.KeyedList = KeyedList;
//# sourceMappingURL=keyed-list.js.map