"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var types_1 = require("../shared/types");
var unsupported_tag_error_1 = require("./error/unsupported-tag.error");
var unsupported_prop_error_1 = require("./error/unsupported-prop.error");
var unsupported_child_error_1 = require("./error/unsupported-child.error");
/**
 *
 * Wraps DOM API so that it is compatible with JSX/TSX expected syntax, by providing
 * a JSX factory function with the necessary signature. Additionally, provides some functions
 * to make working with DOM APIs a bit easier (to read/write).
 *
 * For proper JSX/TSX compilation, a JSX factory function is required with a predetermined
 * signature. Assuming that `renderer` is an instance of `Renderer` (this class),
 * `renderer.create()` is such a factory function. So assuming that the renderer in any context
 * is always named `renderer`, configuring typescript to use `renderer.create` function as
 * its TSX factory allows for proper TSX compilation by Typescript compiler.
 *
 */
var Renderer = /** @class */ (function () {
    function Renderer() {
    }
    /**
     *
     * Creates an HTML `Node` based on given parameters. The signature of this function is designed
     * so that it matches the arguments passed to it match what Typescript compiler passes to
     * a JSX factory.
     *
     * @param tag       the tag of the HTML element to be created. The compiler passes a string in case of
     *                  lowercase-leading arguments (i.e. `sometag`) and passes the object in the context of the same name
     *                  if the first character is uppercase (i.e. `SomeTag`). The former is conventionally
     *                  used to denote native HTML elements, while the latter is used to denote custom elements.
     *                  Passing `fragment` as the tag will cause the renderer to create and return a `DocumentFragment`.
     *
     *
     *                  **NOTE** that the base renderer class is unable to handle custom elements, and in response
     *                  will throw an `UnsupportedTagTypeError`. Any child renderer class might also still
     *                  be unable to handle given custom tags and throw the same error.
     * @param props     The properties of the HTML element to be created. Must be an object whose keys denote the name
     *                  of the property and its values the corresponding values of those properties.
     *                  Uses {@link Renderer#setprop} method to set each property.
     * @param children  Child elements of the HTML element to be created. Each child is appended to the created
     *                  element using {@link Renderer#append} method.
     * @returns {Node}  A `Node` element with given tag (or resolved final tag based on given custom-element), or
     *                  a `DocumentFragment` in-case a fragment is passed.
     *
     * @see Renderer#setprop
     * @see Renderer#append
     *
     */
    Renderer.prototype.create = function (tag, props) {
        var _this = this;
        var children = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            children[_i - 2] = arguments[_i];
        }
        if (typeof tag == 'string') {
            var el_1;
            if (tag === 'fragment')
                el_1 = document.createDocumentFragment();
            else {
                if (props && props.xmlns)
                    el_1 = document.createElementNS("" + props.xmlns, tag);
                else
                    el_1 = document.createElement(tag);
                if (props)
                    Object.entries(props).forEach(function (_a) {
                        var prop = _a[0], target = _a[1];
                        return _this.setprop(prop, target, el_1);
                    });
            }
            children.forEach(function (child) { return _this.append(child, el_1); });
            return el_1;
        }
        else {
            throw new unsupported_tag_error_1.UnsupportedTagTypeError(tag, this);
        }
    };
    /**
     *
     * Sets properties (attributes) of created node based on given properties.
     * The base-renderer is able to handle raw values (`number | boolean | string`),
     * and will throw an `UnsupportedPropError` if other unhandled property types
     * are given.
     *
     * @param prop   the name of the property (attribute) to be set
     * @param target the to be set for the property (attribute)
     * @param host   the element on which the property (attribute) is to be set.
     *
     */
    Renderer.prototype.setprop = function (prop, target, host) {
        if (types_1.isRawValue(target)) {
            if (typeof target === 'boolean' && target)
                host.setAttribute(prop, '');
            else
                host.setAttribute(prop, target.toString());
        }
        else {
            throw new unsupported_prop_error_1.UnsupportedPropError(target, this);
        }
    };
    /**
     *
     * Appends given child on given host `Node`. If passed an array, will append every element of it (recursively).
     * If a raw value (`number | boolean | string`) is passed, a `TextNode` containing the string format will be appended.
     * In case of an unsupported type, an `UnsupportedChildError` will be thrown.
     *
     * @param target the target to be appended.
     * @param host   the host to which the target should be appended to.
     *
     */
    Renderer.prototype.append = function (target, host) {
        var _this = this;
        if (target instanceof Node)
            host.appendChild(target);
        else if (Array.isArray(target))
            target.forEach(function (_) { return _this.append(_, host); });
        else if (types_1.isRawValue(target))
            host.appendChild(document.createTextNode(target.toString()));
        else {
            throw new unsupported_child_error_1.UnsupportedChildError(target, this);
        }
    };
    /**
     *
     * Renders given `Node` on, before or after another `Node`. Usage example:
     *
     * ```tsx
     * renderer.render(<Whatever/>)
     *         .on(document.body);
     *
     * renderer.render(<input/>)
     *         .before(X);
     *
     * renderer.render(Y)
     *         .after(someRef.$);
     * ```
     *
     * @param node the `Node` or `RenderableFunction` to be rendered
     * @returns a `TobeRendered` object that can be used to render the given node on, before or after another `Node`.
     *
     */
    Renderer.prototype.render = function (nodeOrFactory) {
        var node;
        if (typeof nodeOrFactory === 'function')
            node = nodeOrFactory(this);
        else
            node = nodeOrFactory;
        return {
            target: node,
            on: function (host) {
                host.appendChild(node);
                return node;
            },
            before: function (ref) {
                if (ref.parentNode)
                    ref.parentNode.insertBefore(node, ref);
                return node;
            },
            after: function (ref) {
                if (ref.parentNode)
                    ref.parentNode.insertBefore(node, ref.nextSibling);
                return node;
            }
        };
    };
    return Renderer;
}());
exports.Renderer = Renderer;
exports.default = Renderer;
//# sourceMappingURL=renderer.js.map