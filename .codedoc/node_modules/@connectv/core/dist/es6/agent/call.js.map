{"version":3,"file":"call.js","sourceRoot":"","sources":["../../../src/agent/call.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,YAAY,EAAE,MAAM,MAAM,CAAC;AAEpC,OAAO,QAAQ,MAAM,oBAAoB,CAAC;AAE1C,OAAO,GAAG,MAAM,YAAY,CAAC;AAC7B,OAAO,KAAK,MAAM,cAAc,CAAC;AACjC,OAAO,MAAkB,MAAM,eAAe,CAAC;AAS/C;;;;;;;;;;;;;;;;GAgBG;AACH,MAAM,UAAU,IAAI,CAAC,OAAqB,EACxC,GAA+B,EAC/B,KAAiC,EACjC,IAAqB;IAErB,OAAO,GAAG,CAAC,CAAC,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE,EAAE;QACxC,IAAI,MAAM,GAAG,OAAO,EAAE,CAAC;QACvB,IAAI,QAAQ,GAA8B,EAAE,CAAC;QAC7C,IAAI,KAAK,GAAG,IAAI,YAAY,EAAE,CAAC;QAE/B,IAAI,QAAQ,GAAG,GAAG,EAAE;YAClB,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC;YAChD,MAAM,CAAC,KAAK,EAAE,CAAC;YACf,KAAK,CAAC,WAAW,EAAE,CAAC;YACpB,IAAI,KAAK;gBAAE,KAAK,CAAC,KAAK,CAAC,CAAC;QAC1B,CAAC,CAAC;QAEF,IAAI,IAAI;YACN,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,MAAM,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,GAAG,MAAM,EAAE,CAAC,CAAC,CAAC;QAE1F,IAAI,KAAK,GAAG,MAAM,CAAC,SAAS,CAAC,OAAO,IAAI,EAAE,CAAC;QAC3C,IAAI,IAAI;YAAE,KAAK,GAAG,IAAI,EAAE,CAAC;QACzB,KAAK,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,EAAE;YACtB,KAAK,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,SAAS,CACnC,KAAK,CAAC,EAAE,GAAG,QAAQ,EAAE,CAAC,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,KAAK,EAAE,CAAC,CAAC,CAAC,CAAC,EAChD,GAAG,CAAC,EAAE,GAAG,QAAQ,EAAE,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CACnC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;QAEH,IAAI,GAAG;YAAE,GAAG,CAAC,KAAK,CAAC,CAAC;QAEpB,IAAI,IAAI;YACN,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,KAAK,EAAE,KAAK,CAAC,EAAE,EAAE,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC;IACrG,CAAC,CAAC,CAAC;AACL,CAAC;AAGD;;;;;;;;GAQG;AACH,MAAM,UAAU,IAAI,CAAC,OAAqB,EAAE,IAA4B,IAAI,OAAO,KAAK,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;AAGnH,eAAe,IAAI,CAAC","sourcesContent":["import { Subscription } from 'rxjs';\n\nimport emission from '../shared/emission';\n\nimport map from '../pin/map';\nimport value from '../pin/value';\nimport source, { Source } from '../pin/source';\n\nimport { Agent } from './agent';\n\n\nexport type AgentFactory = () => Agent;\nexport type ExecResult = { label: string; value: any };\n\n\n/**\n *\n * Creates a [map](https://connective.dev/docs/map) pin. This map pin will\n * expect objects whose keys matches agents that will be created by given factory.\n * For each such object, the factory will be called and a new instance of the agent\n * will be created, the provided inputs (key-values of the incoming object) will\n * be fed to its inputs, and its first ouput will be passed on.\n *\n * @param factory the agent factory to create new instances per incoming object\n * @param sub a callback to handle the subscription object holding the reference to all\n * subscriptions created in response to each incoming object\n * @param unsub a callback to handle when the created subscriptions of each incoming\n * object are unsubscribed from\n * @param outs an optional function to be used to determine possible outputs instead of utilizing\n * each created agent's signature.\n *\n */\nexport function exec(factory: AgentFactory,\n  sub?: (s: Subscription) => void,\n  unsub?: (s: Subscription) => void,\n  outs?: () => string[]\n) {\n  return map((data, done, error, context) => {\n    let _agent = factory();\n    let _sources = <{[input: string]: Source}>{};\n    let _subs = new Subscription();\n\n    let _cleanup = () => {\n      Object.values(_sources).forEach(s => s.clear());\n      _agent.clear();\n      _subs.unsubscribe();\n      if (unsub) unsub(_subs);\n    };\n\n    if (data)\n      Object.keys(data).forEach((input) => _agent.in(input).from(_sources[input] = source()));\n\n    let _outs = _agent.signature.outputs || [];\n    if (outs) _outs = outs();\n    _outs.forEach((label) => {\n      _subs.add(_agent.out(label).subscribe(\n        value => { _cleanup(); done({ label, value }); },\n        err => { _cleanup(); error(err); }\n      ));\n    });\n\n    if (sub) sub(_subs);\n\n    if (data)\n      Object.entries(data).forEach(([input, value]) => _sources[input].emit(emission(value, context)));\n  });\n}\n\n\n/**\n *\n * Creates an agent using given agent factory, feed its inputs based on key-value\n * pairs of given data, and return a pin who will emit the first output of the created agent.\n *\n * @param factory\n * @param data\n *\n */\nexport function call(factory: AgentFactory, data: {[input: string]: any}) { return value(data).to(exec(factory)); }\n\n\nexport default call;\n"]}