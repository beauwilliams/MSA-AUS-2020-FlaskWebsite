import { Composition } from './composition';
class InlineComposition extends Composition {
    constructor(factory, signature) {
        super(signature);
        this.factory = factory;
        [this.inpins, this.outpins] = this.factory((...children) => children.forEach(child => this.add(child)));
    }
    init() { }
    wire() { }
    build() { }
    createInput(label) { return this.inpins[label]; }
    createOutput(label) { return this.outpins[label]; }
    createEntries() { return Object.values(this.inpins); }
    createExits() { return Object.values(this.outpins); }
}
/**
 *
 * Creates a [composition](https://connective.dev/docs/composition) using given factory function.
 * [Checkout the docs](https://connective.dev/docs/composition) for examples and further information.
 *
 * @param factoryOrSignature either the [signature](https://connective.dev/docs/agent#signature) of
 * the composition or the factory function creating it. If signature is not provided, the factory function
 * will be invoked once to deduce the signature.
 * @param factory the factory function for creating the composition. If provided, the first parameter must
 * be a signature.
 *
 */
export function composition(factoryOrSignature, factory) {
    let signature;
    if (!factory) {
        factory = factoryOrSignature;
        let tracked = [];
        let s = factory((...children) => { tracked = tracked.concat(children); });
        signature = { inputs: Object.keys(s[0]), outputs: Object.keys(s[1]) };
        tracked.forEach(thing => thing.clear());
    }
    else {
        signature = factoryOrSignature;
    }
    let func = () => new InlineComposition(factory, signature);
    func.signature = signature;
    return func;
}
export default composition;
//# sourceMappingURL=inline-composition.js.map