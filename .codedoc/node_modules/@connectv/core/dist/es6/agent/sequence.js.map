{"version":3,"file":"sequence.js","sourceRoot":"","sources":["../../../src/agent/sequence.ts"],"names":[],"mappings":"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","sourcesContent":["import { map, share } from 'rxjs/operators';\n\nimport { Emission } from '../shared/emission';\n\nimport { Control } from '../pin/control';\nimport { Pin } from '../pin/pin';\nimport group from '../pin/group';\nimport _map from '../pin/map';\nimport filter, { block } from '../pin/filter';\nimport pipe from '../pin/pipe';\n\nimport { Agent } from './agent';\n\n\n/**\n *\n * Denotes a token specifying an event sequence.\n * Each token can at each step either accept a new emission,\n * and can complete on a list of emissions.\n *\n */\nexport interface SequenceToken {\n  /**\n   *\n   * Determines whether the token would accept the new incoming emission\n   * (i.e. it could still be satisfied in the future if this emission was accepted),\n   * based on the emission itself and the list of emissions without the newly arrived emission.\n   *\n   * @param val the newly arrived emission\n   * @param list the already accepted list of emissions\n   *\n   */\n  accepts(val: Emission, list: Emission[]): boolean;\n\n  /**\n   *\n   * Determines whether the token can be considered completed, i.e.\n   * the current list of emissions satisfies its conditions.\n   *\n   * @param list\n   *\n   */\n  complete(list: Emission[]): boolean;\n}\n\n\n/**\n *\n * Creates a sequence token that denotes events happening between `min` and\n * `max` number of times.\n *\n * @param min the minimum number of times the event should happen\n * @param max the maximum number of times the event should happen\n *\n */\nexport function range(min: number, max?: number) {\n  return <SequenceToken>{\n    accepts(_, list) { return max === undefined || list.length < max; },\n    complete(list) { return list.length >= min; }\n  }\n}\n\n/**\n *\n * Creates a sequence token that denotes events happening a\n * specified number of times exactly\n *\n * @param c the number of times the event should happen.\n *\n */\nexport function count(c: number) { return range(c, c); }\n\n/**\n *\n * Sequence token denoting an event that may or may not happen (multiple times).\n *\n */\nexport const maybesome = range(0);\n\n/**\n *\n * Sequence token denoting an event that happens at least once.\n *\n */\nexport const some = range(1);\n\nexport type SequenceTokenIndicator = number | '*' | '+' | SequenceToken;\n\n\n/**\n *\n * Represents [sequence](https://connective.dev/docs/sequence) agents.\n *\n */\nexport class Sequence extends Agent {\n  readonly tokens: SequenceToken[];\n  private _control: Control;\n  private _relay: Pin;\n  public _seq: Emission[][];\n  private _head = 0;\n\n  /**\n   *\n   * @param tokens the tokens denoting the sequence of desired events. Each token must be\n   * - A `SequenceToken`,\n   * - A number, meaning that an event should happen that number of times exactly,\n   * - `'+'` meaning the event should happen at least once,\n   * - `'*'` meaning the event may or may not happen one or multiple times.\n   *\n   */\n  constructor(tokens: SequenceTokenIndicator[]) {\n    super({inputs: tokens.map((_, index) => index.toString()), outputs: ['out']});\n\n    this._control = new Control();\n    this._relay = new Pin();\n\n    this.tokens = tokens.map(t => {\n      if (typeof t == 'number') return count(t);\n      if (t === '+') return some;\n      if (t === '*') return maybesome;\n      return t;\n    });\n\n    tokens.forEach((_, index) => {\n      this.in(index).to(pipe(map(e => {\n        this._take(e, index, true);\n        return e;\n      }))).to(this._relay);\n    });\n\n    this.reset();\n  }\n\n  private _take(emission: Emission, index: number, retry: boolean = false) {\n    if (index == this._head) {\n      if (this.tokens[index].accepts(emission, this._seq[index]))\n        this._seq[index].push(emission);\n      else {\n        this.reset();\n        if (retry)\n          this._take(emission, index);\n      }\n    }\n    else {\n      if (index < this._head) {\n        this.reset();\n        this._take(emission, index);\n      }\n      else {\n        if (this._seek(index))\n          this._take(emission, index, retry);\n        else {\n          this.reset();\n          if (this._seek(index))\n            this._take(emission, index, retry);\n        }\n      }\n    }\n  }\n\n  private _seek(index: number): boolean {\n    for (let i = this._head; i < index; i++)\n      if (!this.tokens[i].complete(this._seq[i]))\n        return false;\n\n    this._head = index;\n    return true;\n  }\n\n  private get _complete(): boolean {\n    return this._seq.every((e, index) => this.tokens[index].complete(e));\n  }\n\n  protected reset(): this {\n    this._seq = this.tokens.map(_ => []);\n    this._head = 0;\n    return this;\n  }\n\n  protected createOutput(label: string) {\n    this.checkOutput(label);\n    return group(\n      this._control.to(_map(() => this.reset())).to(block()),\n      this._relay.to(filter(() => this._complete))\n    ).to(pipe(map(() => {\n      let _vals = this._seq.map(_comp => (_comp.length==1)?(_comp[0].value):(_comp.map(_ => _.value)));\n      let _emission = Emission.from(this._seq.reduce((all, list) => all.concat(list), [])\n        , (this.tokens.length == 1)?_vals[0]:_vals);\n\n      return _emission;\n    }), share()));\n  }\n\n  protected createEntries() { return (this.signature.inputs || []).map(i => this.in(i)) }\n  protected createExits() { return [this.output] }\n\n  public clear() {\n    this.reset();\n    this._control.clear();\n    this._relay.clear();\n    return super.clear();\n  }\n\n  /**\n   *\n   * Resets the sequence being tracked when receiving emissions\n   * on `.control`.\n   *\n   */\n  public get control() { return this._control; }\n\n  /**\n   *\n   * Shortcut for `.out('out')`, which will emit completed sequences.\n   * [Read this](https://connective.dev/docs/sequence#signature) for more details.\n   *\n   */\n  public get output() { return this.out('out'); }\n}\n\n\n/**\n *\n * Creates a [sequence](https://connective.dev/docs/sequence) agent.\n * Sequence agents can determine if a specific sequence of events has occured.\n * [Checkout the docs](https://connective.dev/docs/sequence) for examples and further information.\n *\n * @param tokens the tokens denoting the sequence of desired events. Each token must be\n * - A `SequenceToken`,\n * - A number, meaning that an event should happen that number of times exactly,\n * - `'+'` meaning the event should happen at least once,\n * - `'*'` meaning the event may or may not happen one or multiple times.\n *\n */\nexport function sequence(...tokens: SequenceTokenIndicator[]) { return new Sequence(tokens); }\n\n\nexport default sequence;\n"]}