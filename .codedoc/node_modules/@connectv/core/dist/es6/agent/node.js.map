{"version":3,"file":"node.js","sourceRoot":"","sources":["../../../src/agent/node.ts"],"names":[],"mappings":"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","sourcesContent":["import { ContextType, ErrorCallback } from '../shared/types';\n\nimport { PinLike } from '../pin/pin-like';\nimport control, { Control } from '../pin/control';\nimport pack from '../pin/pack';\nimport filter from '../pin/filter';\nimport map from '../pin/map';\n\nimport { OutputNotInSignature } from './errors/signature-mismatch.error';\nimport { InsufficientInputs } from './errors/insufficient-input.error';\n\nimport { Signature } from './signature';\nimport { Agent } from './agent';\nimport { NodeLike } from './node-like';\n\n\nexport type NodeInputs = ContextType;\nexport type NodeOutput = (out: string, data?: any) => void;\n\n\n/**\n *\n * Denotes the signature of a [node](https://connective.dev/docs/node).\n *\n */\nexport interface NodeSignature extends Signature {\n  /**\n   *\n   * The list of inputs that are required for the node to run\n   *\n   */\n  required?: string[];\n}\n\n\n/**\n *\n * Represents a [node](https://connective.dev/docs/node).\n *\n */\nexport abstract class Node extends Agent implements NodeLike {\n  private _control: Control;\n  private _res: PinLike;\n\n  private _control_required = true;\n\n  /**\n   *\n   * @param signature the [signature](https://connective.dev/docs/agent#signature) of the node.\n   *\n   */\n  constructor(signature: NodeSignature) {\n    super(signature);\n\n    this._control = control();\n\n    this._res =\n    pack(this.inputs, this.control.to(map(() => this._control_required = false)))\n    .to(filter(() => !this._control_required))\n    .to(map((all, callback, error, context) => {\n      if (this._control.connected)\n        this._control_required = true;\n      if (signature.required && signature.required.some(label => !(all && all[0] && label in all[0])))\n        error(new InsufficientInputs(signature.required.filter(label => !(all && all[0] && label in all[0]))));\n      else {\n        this.run(all[0], (out: string, data?: any) => {\n          if (!this.signature.outputs.includes(out)) {\n            error(new OutputNotInSignature(out, this.signature));\n          }\n          else {\n            callback({out, data});\n          }\n        }, error, context);\n      }\n    }));\n  }\n\n  /**\n   *\n   * A node waits for its `.control` before each execution, if any pins are\n   * connected to `.control`.\n   *\n   */\n  public get control(): Control { return this._control; }\n\n  /**\n   *\n   * Override this to outline what should your node do during each execution.\n   *\n   * @param inputs a named map of inputs\n   * @param output a callback to emit outputs\n   * @param error a callback to emit errors\n   * @param context the context of the execution\n   *\n   */\n  protected abstract run(\n    inputs: NodeInputs,\n    output: NodeOutput,\n    error: ErrorCallback,\n    context: ContextType,\n  ): void;\n\n  protected createOutput(label: string): PinLike {\n    this.checkOutput(label);\n    return this._res\n      .to(filter((res: any) => res.out == label))\n      .to(map((res: any) => res.data))\n    ;\n  }\n\n  protected createEntries() {  return (this.signature.inputs || []).map(i => this.in(i)); }\n  protected createExits() { return this.signature.outputs.map(o => this.out(o)); }\n\n  clear() {\n    this.control.clear();\n    return super.clear();\n  }\n}\n\n\nexport type NodeRunFunc = (inputs: NodeInputs, output: NodeOutput, error: ErrorCallback, context: ContextType) => void;\n\n\nclass _CodeNode extends Node {\n  constructor(signature: Signature, private _run: NodeRunFunc) { super(signature); }\n\n  protected run(inputs: NodeInputs, output: NodeOutput,\n    error: ErrorCallback, context: ContextType)\n    { this._run.apply(this, [inputs, output, error, context])};\n}\n\n\n/**\n *\n * Creates a [node](https://connective.dev/docs/node).\n * [Checkout the docs](https://connective.dev/docs/node) for examples and further information.\n *\n * @param signature the signature of the node\n * @param run the execution function of the node\n *\n */\nexport function node(signature: Signature, run: NodeRunFunc) { return () => new _CodeNode(signature, run); }\n\n\nexport default node;\n"]}