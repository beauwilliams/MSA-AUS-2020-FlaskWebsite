{"version":3,"file":"expr.js","sourceRoot":"","sources":["../../../src/agent/expr.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,IAAI,EAA0B,MAAM,QAAQ,CAAC;AAQtD;;;;GAIG;AACH,MAAM,OAAO,IAAK,SAAQ,IAAI;IAU5B;;;;;;OAMG;IACH,YAAY,YAAuC,EAAE,IAAsB;QACzE,KAAK,CAAC;YACJ,MAAM,EAAE,CAAC,OAAO,YAAY,KAAK,UAAU,CAAC,CAAA,CAAC,CAAA,EAAE,CAAA,CAAC,CAAA,YAAY;YAC5D,QAAQ,EAAE,CAAC,OAAO,YAAY,KAAK,UAAU,CAAC,CAAA,CAAC,CAAA,EAAE,CAAA,CAAC,CAAA,YAAY;YAC9D,OAAO,EAAE,CAAC,QAAQ,CAAC;SACpB,CAAC,CAAC;QAEH,IAAI,CAAC,IAAI,GAAG,IAAI,CAAA,CAAC,CAAA,IAAI,CAAA,CAAC,CAAA,YAAY,CAAC;IACrC,CAAC;IAES,GAAG,CAAC,MAAkB,EAAE,MAAkB,EAAE,KAAoB,EAAE,OAAoB;QAC9F,IAAI,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,CAAA,CAAC,CAAA,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAA,CAAC,CAAA,EAAE,CAAC;QAChF,IAAI;YACF,IAAI,GAAG,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,SAAS,EAAE,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC;YAC7D,IAAI,OAAO,GAAG,KAAK,UAAU;gBAC3B,GAAG,CAAC,KAAK,CAAC,SAAS,EAAE,CAAC,CAAC,GAAQ,EAAE,EAAE,CAAE,MAAM,CAAC,QAAQ,EAAE,GAAG,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC;;gBAEpE,MAAM,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC;SACzB;QAAC,OAAO,GAAG,EAAE;YACZ,KAAK,CAAC,GAAG,CAAC,CAAC;SACZ;IACH,CAAC;IAED;;;;;OAKG;IACH,IAAW,MAAM,KAAK,OAAO,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;CACnD;AAKD;;;;;;;;;GASG;AACH,MAAM,UAAU,IAAI,CAAC,YAAkC,EAAE,IAAe;IACtE,IAAI,IAAI;QAAE,OAAO,IAAI,IAAI,CAAC,YAAwB,EAAE,IAAI,CAAC,CAAC;SACrD;QACH,IAAI,IAAI,GAAG,YAAwB,CAAC;QACpC,OAAO,IAAI,IAAI,CACb,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE,EAAC,MAAM,EAAE,IAAI,CAAC,MAAM,EAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAG,EAAE,CAAQ,EAAE,EAAE,CAAC,CAAC,CAAC,QAAQ,EAAE,CAAC,EAC1E,IAAI,CACL,CAAC;KACH;AACH,CAAC;AAGD,eAAe,IAAI,CAAC","sourcesContent":["import { ErrorCallback, ContextType } from '../shared/types';\n\nimport { Node, NodeInputs, NodeOutput } from './node';\n\n\nexport type ExprNoArgFunc = (error: ErrorCallback, context: ContextType) => any;\nexport type ExprWithArgFunc = (...args: any[]) => any;\nexport type ExprFunc = ExprNoArgFunc | ExprWithArgFunc;\n\n\n/**\n *\n * Represents [expression](https://connective.dev/docs/expr) agents.\n *\n */\nexport class Expr extends Node {\n  /**\n   *\n   * The expression function\n   *\n   */\n  readonly func: any;\n\n  constructor(func: ExprNoArgFunc);\n  constructor(inputs: string[], func: ExprWithArgFunc);\n  /**\n   *\n   * @param inputsOrFunc either a list of names for the inputs of the\n   * [signature](https://connective.dev/docs/agent#signature) or the expr function\n   * @param func the expr function (if this is provided, the first parameter must be alist of string)\n   *\n   */\n  constructor(inputsOrFunc?: string[] | ExprNoArgFunc, func?: ExprWithArgFunc){\n    super({\n      inputs: (typeof inputsOrFunc === 'function')?[]:inputsOrFunc,\n      required: (typeof inputsOrFunc === 'function')?[]:inputsOrFunc,\n      outputs: ['result']\n    });\n\n    this.func = func?func:inputsOrFunc;\n  }\n\n  protected run(inputs: NodeInputs, output: NodeOutput, error: ErrorCallback, context: ContextType) {\n    let _ilist = this.signature.inputs?this.signature.inputs.map(i => inputs[i]):[];\n    try {\n      let val = this.func.apply(undefined, _ilist.concat(context));\n      if (typeof val === 'function')\n        val.apply(undefined, [(out: any) =>  output('result', out), error]);\n      else\n        output('result', val);\n    } catch (err) {\n      error(err);\n    }\n  }\n\n  /**\n   *\n   * Shortcut for `.out('result')`. The result of the evaluation of the\n   * expression will be emitted via this output.\n   *\n   */\n  public get result() { return this.out('result'); }\n}\n\n\nexport function expr(func: ExprFunc): Expr;\nexport function expr(inputs: string[], func: ExprFunc): Expr;\n/**\n *\n * Creates an [expr](https://connective.dev/docs/expr) agent.\n * Expr agents turn a function into an agent.\n * [Checkout the docs](https://connective.dev/docs/expr) for examples and further information.\n *\n * @param inputsOrFunc either a list of names for the inputs of the signature or the function to convert\n * @param func the function to convert (if provided, the first argument must be a list of strings)\n *\n */\nexport function expr(inputsOrFunc?: string[] | ExprFunc, func?: ExprFunc): Expr {\n  if (func) return new Expr(inputsOrFunc as string[], func);\n  else {\n    let func = inputsOrFunc as ExprFunc;\n    return new Expr(\n      Array.apply(0, {length: func.length}).map((_:0, i:number) => i.toString()),\n      func\n    );\n  }\n}\n\n\nexport default expr;\n"]}