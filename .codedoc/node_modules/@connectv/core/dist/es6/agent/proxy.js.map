{"version":3,"file":"proxy.js","sourceRoot":"","sources":["../../../src/agent/proxy.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,YAAY,EAAE,MAAM,MAAM,CAAC;AAIpC,OAAO,EAAE,MAAM,EAAE,MAAM,eAAe,CAAC;AAGvC,OAAO,EAAE,KAAK,EAAE,MAAM,SAAS,CAAC;AAIhC;;;;GAIG;AACH,MAAM,OAAO,KAAM,SAAQ,KAAK;IAC9B;;;;;;;;;OASG;IACI,KAAK,CAAC,KAAgB;QAE3B,IAAI,IAAI,GAAG,IAAI,YAAY,CAAC,GAAG,EAAE;YAC/B,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;QACrB,CAAC,CAAC,CAAC;QAEH,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QACxE,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;YACnC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC,QAAkB,EAAE,EAAE;gBACtE,KAAK,CAAC,CAAC,CAAY,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YACtC,CAAC,CAAC,CAAC,CAAC;QACN,CAAC,CAAC,CAAC;QAEH,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;IAC1B,CAAC;IAES,YAAY,CAAC,KAAa;QAClC,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;QACxB,OAAO,IAAI,MAAM,EAAE,CAAC;IACtB,CAAC;CACF;AAGD;;;;;;;;GAQG;AACH,MAAM,UAAU,KAAK,CAAC,SAAoB,IAAI,OAAO,IAAI,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;AAG5E,eAAe,KAAK,CAAC","sourcesContent":["import { Subscription } from 'rxjs';\n\nimport { Emission } from '../shared/emission';\n\nimport { Source } from '../pin/source';\n\nimport { Signature } from './signature';\nimport { Agent } from './agent';\nimport { AgentLike } from './agent-like';\n\n\n/**\n *\n * Represents [proxy](https://connective.dev/docs/proxy) agents.\n *\n */\nexport class Proxy extends Agent {\n  /**\n   *\n   * Proxies given agent, connecting it to the rest of the flow\n   * that the proxy itself is connected to.\n   *\n   * @param agent\n   * @returns a [subscription](https://rxjs-dev.firebaseapp.com/guide/subscription) object\n   * that can be unsubscribed (call `.unsubscribe()`) to unproxy given agent.\n   *\n   */\n  public proxy(agent: AgentLike): Subscription {\n\n    let subs = new Subscription(() => {\n      this.untrack(subs);\n    });\n\n    this.inputs.entries.forEach(entry => agent.in(entry[0]).from(entry[1]));\n    this.outputs.entries.forEach(entry => {\n      subs.add(agent.out(entry[0]).observable.subscribe((emission: Emission) => {\n        (entry[1] as Source).emit(emission);\n      }));\n    });\n\n    return this.track(subs);\n  }\n\n  protected createOutput(label: string) {\n    this.checkOutput(label);\n    return new Source();\n  }\n}\n\n\n/**\n *\n * Creates a [proxy](https://connective.dev/docs/proxy) agent.\n * [Checkout the docs](https://connective.dev/docs/proxy) for examples and further information.\n *\n * @param signature the signature of the proxied agent (or a projection of the signature that needs\n * to be proxied).\n *\n */\nexport function proxy(signature: Signature) { return new Proxy(signature); }\n\n\nexport default proxy;\n"]}