{"version":3,"file":"emission.js","sourceRoot":"","sources":["../../../src/shared/emission.ts"],"names":[],"mappings":"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","sourcesContent":["import { ContextType } from './types';\n\n/**\n *\n * When the same key appears in multiple [emissions](https://connective.dev/docs/emission),\n * with conflicting values, when the emissions are merged, the corresponding values are\n * stored within an instance of `MergedEmissionContextVal`. You can read these values using\n * `.values` property:\n *\n * ```typescript\n * myFlow.observable.subscribe(emission => {\n *  if (emission.context.someKey instanceof MergedEmissionContextVal)\n *    emission.context.someKey.values.forEach(value => handle(value));\n *  else\n *    handle(emission.context.someKey);\n * });\n * ```\n *\n */\nexport class MergedEmissionContextVal {\n  constructor(readonly values: any[]) {}\n}\n\n\nconst _Unset = {};\n\n/**\n *\n * Represents emissions passing through reactive flows.\n * mainly has a `.value` property, which is the value that this emission is wrapping,\n * and `.context` property, which is the context of the emission.\n *\n * [read more here](https://connective.dev/docs/emission).\n *\n */\nexport class Emission {\n  /**\n   *\n   * @param value the value of the emission\n   * @param context the context of the emission\n   *\n   */\n  constructor(\n    readonly value: any = undefined,\n    readonly context: ContextType = {},\n  ) {}\n\n  /**\n   *\n   * Will create a merged emission from given emissions.\n   *\n   * @param emissions the emissions to merge\n   * @param value the value to set on the forked emission (by default will be an array of the merged emissions' values).\n   *\n   */\n  public static from(emissions: Emission[], value: any = _Unset): Emission {\n    return new Emission(\n      (value === _Unset)?(emissions.map(emission => emission.value)):(value),\n      emissions.reduce((ctx, emission) => {\n        Object.entries(emission.context).forEach(([key, value]) => {\n          if (key in ctx) {\n            if (ctx[key] == value) return ctx;\n\n            if (ctx[key] instanceof MergedEmissionContextVal) {\n              if (value instanceof MergedEmissionContextVal) {\n                ctx[key] = new MergedEmissionContextVal(ctx[key].values.concat(\n                  value.values.filter(v => !ctx[key].values.includes(v))\n                ));\n              }\n              else {\n                if (!ctx[key].values.includes(value))\n                  ctx[key].values.push(value);\n              }\n            }\n            else {\n              if (value instanceof MergedEmissionContextVal) {\n                if (value.values.includes(ctx[key]))\n                  ctx[key] = value;\n                else\n                  ctx[key] = new MergedEmissionContextVal([ctx[key]].concat(value.values));\n              }\n              else\n                ctx[key] = new MergedEmissionContextVal([ctx[key], value]);\n            }\n          }\n          else ctx[key] = value;\n        });\n\n        return ctx;\n      }, <ContextType>{})\n    )\n  }\n\n  /**\n   *\n   * Creates a new `Emission` with the same context but the new value\n   *\n   * @param value\n   *\n   */\n  public fork(value: any): Emission {\n    return new Emission(value, this.context);\n  }\n}\n\n\n/**\n *\n * Creates an emission with given value and context. You can feed this object to\n * your reactive flows using [`source()`](https://connective.dev/docs/source) for example:\n *\n * ```typescript\n * let a = source();\n * a.emit(emission(42, { reason: 'it is the ultimate answer' }));\n * ```\n *\n * @param value\n * @param context\n */\nexport function emission(value?: any, context?: ContextType) {\n  return new Emission(value, context);\n}\n\n\nexport default emission;\n"]}