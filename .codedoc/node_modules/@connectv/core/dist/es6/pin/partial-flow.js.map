{"version":3,"file":"partial-flow.js","sourceRoot":"","sources":["../../../src/pin/partial-flow.ts"],"names":[],"mappings":"AAGA,OAAO,EAAE,OAAO,EAAE,MAAM,mBAAmB,CAAC;AAI5C,OAAO,KAAK,EAAE,EAAE,KAAK,EAAE,MAAM,SAAS,CAAC;AAGvC,EAAE;AACF,8BAA8B;AAC9B,iFAAiF;AACjF,6DAA6D;AAC7D,EAAE;AACF;;;;;GAKG;AACH,MAAM,OAAgB,WAAY,SAAQ,OAAO;IAiB/C;;;;;;;;OAQG;IACH,IAAI,CAAC,GAAG,IAAe;QACrB,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,CAAC;IACpC,CAAC;IAED;;;;;;;;OAQG;IACH,EAAE,CAAC,GAAG,IAAe;QACnB,OAAO,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,CAAC;IAChC,CAAC;IAED;;;;;;;;OAQG;IACH,UAAU,CAAC,GAAG,IAAe;QAC3B,OAAO,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,GAAG,IAAI,CAAC,CAAC;IAC1C,CAAC;IAED;;;;;;;;OAQG;IACH,QAAQ,CAAC,GAAG,IAAe;QACzB,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,GAAG,IAAI,CAAC,CAAC;IACtC,CAAC;IAED,IAAI,UAAU;QACZ,OAAO,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC;IAC/B,CAAC;IAID;;;;;OAKG;IACH,SAAS,CACP,CAA+C,EAC/C,EAAkB,EAClB,GAAoB;QAEpB,OAAO,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,CAAQ,EAAE,EAAE,EAAE,GAAG,CAAC,CAAC;IACjD,CAAC;CACF;AAMD,MAAM,UAAW,SAAQ,WAAW;IAGlC,YAAqB,OAA2B;QAC9C,KAAK,EAAE,CAAC;QADW,YAAO,GAAP,OAAO,CAAoB;QAE9C,IAAI,CAAC,OAAO,EAAE,KAAK,CAAC,GAAG,OAAO,EAAE,CAAC;QACjC,IAAI,CAAC,OAAO,GAAG,CAAC,OAAO,YAAY,KAAK,CAAC,CAAA,CAAC,CAAA,OAAO,CAAA,CAAC,CAAA,KAAK,CAAC,GAAG,OAAO,CAAC,CAAC;QACpE,IAAI,CAAC,KAAK,GAAG,CAAC,KAAK,YAAY,KAAK,CAAC,CAAA,CAAC,CAAA,KAAK,CAAA,CAAC,CAAA,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;IAC9D,CAAC;CACF;AAGD;;;;;;;;;GASG;AACH,MAAM,UAAU,WAAW,CAAC,OAA2B,IAAI,OAAO,IAAI,UAAU,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;AAG5F,eAAe,WAAW,CAAC","sourcesContent":["import { Observable, PartialObserver, Subscription } from 'rxjs';\n\nimport { Emission } from '../shared/emission';\nimport { Tracker } from '../shared/tracker';\nimport { ResolveCallback, ErrorCallback, NotifyCallback } from '../shared/types';\n\nimport { PinLike } from './pin-like';\nimport group, { Group } from './group';\n\n\n//\n// TODO: write tests for this.\n// TODO: make Agent inherit this, but default throwing error when used like this.\n// TODO: make common agent types act as proper partial flows.\n//\n/**\n *\n * Represents a partial reactive flow, with some entry pins going into it\n * and some exit pins coming out of it.\n *\n */\nexport abstract class PartialFlow extends Tracker implements PinLike {\n  /**\n   *\n   * Override this to specify the entry pins of this partial flow.\n   * Read more about this [here](https://connective.dev/docs/agent#implicit-connection).\n   *\n   */\n  abstract get entries(): Group;\n\n  /**\n   *\n   * Override this to specify the exit pins of this partial flow.\n   * Read more about this [here](https://connective.dev/docs/agent#implicit-connection).\n   *\n   */\n  abstract get exits(): Group;\n\n  /**\n   *\n   * Connects all given pins to all of its entry pins\n   *\n   * @param pins\n   * @returns a [group](https://connective.dev/docs/group) of the given pins. If any `PartialFlow`\n   * was among the given pins, its entry pins will be added to the group.\n   *\n   */\n  from(...pins: PinLike[]): PinLike {\n    return this.entries.from(...pins);\n  }\n\n  /**\n   *\n   * Connects all of its exit pins to given pins\n   *\n   * @param pins\n   * @returns a [group](https://connective.dev/docs/group) of the given pins. If any `PartialFlow`\n   * was among the given pins, its exit pins added to the group.\n   *\n   */\n  to(...pins: PinLike[]): PinLike {\n    return this.exits.to(...pins);\n  }\n\n  /**\n   *\n   * Connects all given pins serially to its entry pins\n   *\n   * @param pins\n   * @returns a [group](https://connective.dev/docs/group) of the given pins. If any `PartialFlow`\n   * was among the given pins, its entry pins will be added to the group.\n   *\n   */\n  serialFrom(...pins: PinLike[]): PinLike {\n    return this.entries.serialFrom(...pins);\n  }\n\n  /**\n   *\n   * Connects all of its exit pins to given pins\n   *\n   * @param pins\n   * @returns a [group](https://connective.dev/docs/group) of the given pins. If any `PartialFlow`\n   * was among the given pins, its exit pins added to the group.\n   *\n   */\n  serialTo(...pins: PinLike[]): PinLike {\n    return this.exits.serialTo(...pins);\n  }\n\n  get observable(): Observable<Emission> {\n    return this.exits.observable;\n  }\n\n  subscribe(observer?: PartialObserver<any>): Subscription;\n  subscribe(next?: (value: any) => void, error?: (error: any) => void, complete?: () => void): Subscription;\n  /**\n   *\n   * Subscribes to all of its exit pins. Returns a composite subscription of\n   * all created subscriptions.\n   *\n   */\n  subscribe(\n    _?: PartialObserver<any> | ResolveCallback<any>,\n    __?: ErrorCallback,\n    ___?: NotifyCallback,\n  ): Subscription {\n    return this.exits.subscribe(_ as any, __, ___);\n  }\n}\n\n\nexport type PartialFlowFactory = () => [Group | PinLike[], Group | PinLike[]];\n\n\nclass InlineFlow extends PartialFlow {\n  entries: Group; exits: Group;\n\n  constructor(readonly factory: PartialFlowFactory) {\n    super();\n    let [entries, exits] = factory();\n    this.entries = (entries instanceof Group)?entries:group(...entries);\n    this.exits = (exits instanceof Group)?exits:group(...exits);\n  }\n}\n\n\n/**\n *\n * Creates a partial flow, using the given factory function. The factory function\n * should return either a [`group`](https://connective.dev/docs/group) or an array\n * of [pins](https://connective.dev/docs/pin) for inputs, and a group or an array of pins\n * for outputs, in array format itself (first object being the inputs, second the outputs).\n *\n * @param factory\n *\n */\nexport function partialFlow(factory: PartialFlowFactory) { return new InlineFlow(factory); }\n\n\nexport default partialFlow;"]}