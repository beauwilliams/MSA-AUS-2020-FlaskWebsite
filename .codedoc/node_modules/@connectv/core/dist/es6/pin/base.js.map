{"version":3,"file":"base.js","sourceRoot":"","sources":["../../../src/pin/base.ts"],"names":[],"mappings":"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","sourcesContent":["import { Observable, PartialObserver, Subscription } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nimport { Emission } from '../shared/emission';\nimport { Tracker } from '../shared/tracker';\nimport { ResolveCallback, ErrorCallback, NotifyCallback } from '../shared/types';\n\nimport { Group, traverseFrom, traverseTo } from './group';\nimport { PinLike } from './pin-like';\nimport { PartialFlow } from './partial-flow';\n\n\n//\n// TODO: write tests for this\n//\n/**\n *\n * The base class for [pins](https://connective.dev/docs/pin).\n *\n */\nexport abstract class BasePin extends Tracker implements PinLike {\n  /**\n   *\n   * Connects given [pin](https://connective.dev/docs/pin) to this pin.\n   * Note that the operation might not be possible and result in an error.\n   *\n   * @param _  the pin that gets connected to this pin.\n   *\n   */\n  abstract connect(_: PinLike): this;\n\n  /**\n   *\n   * The underlying observable of the pin. You can use this property\n   * to access the [emissions](https://connective.dev/docs/emission) instead of\n   * values, or to connect your CONNECTIVE flow into another observable sequence.\n   *\n   */\n  abstract observable: Observable<Emission>;\n\n  /**\n   *\n   * Connects this pin to given pins. Will invoke `.from()` on the receiving pins.\n   * If any `PartialFlow` is among the given pins, the connection will be made to all of\n   * its entry pins (read more about partial flows [here](https://connective.dev/docs/agent#implicit-connection)).\n   *\n   * @param pins the pins to connect to\n   * @returns a [group](https://connective.dev/docs/group) of the given pins. If any `PartialFlow`\n   * was among the given pins, its exit pins added to the group.\n   *\n   */\n  to(...pins: PinLike[]) {\n    pins.forEach(pin => pin.from(this));\n    return traverseTo(...pins);\n  }\n\n  /**\n   *\n   * Connects all given pins to this pin, by calling `.connect()` on each of them.\n   * If any `PartialFlow` is among given pins, the exit pins of the partial flow will be\n   * connected to this pin\n   * (read more about partial flows [here](https://connective.dev/docs/agent#implicit-connection)).\n   *\n   * @param pins the pins to be connected to this pin\n   * @returns a [group](https://connective.dev/docs/group) of the given pins. If any `PartialFlow`\n   * was among the given pins, its entry pins will be added to the group.\n   *\n   */\n  from(...pins: PinLike[]) {\n    pins.forEach(pin => {\n      if (pin instanceof Group)\n        pin.pins.forEach(p => this.connect(p));\n      else if (pin instanceof PartialFlow)\n        pin.exits.pins.forEach(o => this.connect(o));\n      else\n        this.connect(pin);\n    });\n\n    return traverseFrom(...pins);\n  }\n\n  /**\n   *\n   * Connectss to given pins. This is same as `.to()`, except that when a `PartialFlow`\n   * is among the given pins, this pin will be connected only to its first entry pin\n   * (read more about partial flows [here](https://connective.dev/docs/agent#implicit-connection)).\n   *\n   * @param pins pins to connect this pin to\n   * @returns a [group](https://connective.dev/docs/group) of the given pins. If any `PartialFlow`\n   * was among the given pins, its exit pins added to the group.\n   *\n   */\n  serialTo(...pins: PinLike[]) {\n    pins.forEach(pin => {\n      if (pin instanceof PartialFlow) {\n        if (pin.entries.pins.length > 0)\n          pin.entries.pins[0].from(this);\n      }\n      else pin.from(this);\n    })\n\n    return traverseTo(...pins);\n  }\n\n  /**\n   *\n   * Connects given pins to this pin. This is same as `.from()`, except that when a `PartialFlow`\n   * is among given pins, only its first exit pin will be connected to this pin\n   * (read more about partial flows [here](https://connective.dev/docs/agent#implicit-connection)).\n   *\n   * @param pins pins to connect to this pin\n   * @returns a [group](https://connective.dev/docs/group) of the given pins. If any `PartialFlow`\n   * was among the given pins, its entry pins will be added to the group.\n   *\n   */\n  serialFrom(...pins: PinLike[]) {\n    pins.forEach(pin => {\n      if (pin instanceof PartialFlow) {\n        if (pin.exits.pins.length > 0)\n          this.connect(pin.exits.pins[0]);\n      }\n      else this.connect(pin);\n    });\n\n    return traverseTo(...pins);\n  }\n\n  subscribe(observer?: PartialObserver<any>): Subscription;\n  subscribe(next?: (value: any) => void, error?: (error: any) => void, complete?: () => void): Subscription;\n  /**\n   *\n   * Subscribes given function or partial observer to the observable of this pin.\n   * The subscriber will recieve the emitted values and not the emission object itself,\n   * so if you need to access the emission (for example, to access its context),\n   * use `.observable.subscribe()` instead.\n   *\n   * @param observerOrNext either an [observer object](https://github.com/ReactiveX/rxjs/blob/master/doc/observer.md),\n   * or a callback handling incoming values.\n   * @param error a callback handling incoming errors.\n   * @param complete a callback that will be invoked when the underlying observable sequence completes, for example\n   * when the sources are all cleared out.\n   * @returns the subscription object. The pin itself will track this subscription and clear it out when\n   * its `.clear()` is invoked. If you wish to unsubscribe the subscription earlier than the time you clear\n   * the pin out, then hold a reference to it and also remove it from subscriptions tracked by the pin\n   * using `.untrack()`.\n   *\n   */\n  subscribe(\n    observerOrNext?: PartialObserver<any> | ResolveCallback<any>,\n    error?: ErrorCallback,\n    complete?: NotifyCallback,\n  ): Subscription {\n    if (error || complete)\n      return this.track(this.observable.pipe(\n          map((e: Emission) => e.value)\n        ).subscribe(observerOrNext as ResolveCallback<any>, error, complete));\n    else\n      return this.track(this.observable.pipe(\n        map((e: Emission) => e.value)\n      ).subscribe(observerOrNext as any));\n  }\n}\n"]}