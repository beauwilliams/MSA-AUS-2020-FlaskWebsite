import { Observable } from 'rxjs';
import { Emission } from '../shared/emission';
import { BasePin } from './base';
import { PinLike } from './pin-like';
/**
 *
 * Represents pins that you can connect other pins to.
 *
 */
export declare abstract class Connectible extends BasePin {
    private _inbound;
    private _observable;
    private _resolving;
    private _deferred;
    private _deference_connected;
    constructor();
    /**
     *
     * @note it will throw an error if this pin is already locked.
     * You can read more about this [here](https://connective.dev/docs/pin#subscribing-and-binding).
     *
     */
    connect(pin: PinLike): this;
    /**
     *
     * @note Accessing this property locks the pin.
     * You can read more about this [here](https://connective.dev/docs/pin#subscribing-and-binding).
     *
     */
    get observable(): Observable<Emission>;
    /**
     *
     * @note Calling `.clear()` will unlock the pin and disconnect it from
     * all the pins its connected to (removing their references). There is no guarantee
     * that the pin will be usable afterwards.
     *
     */
    clear(): this;
    /**
     *
     * @returns `true` if the pin is locked, `false` if not.
     * You can read more about this [here](https://connective.dev/docs/pin#subscribing-and-binding).
     *
     */
    get locked(): boolean;
    /**
     *
     * @returns `true` if any other pin is connected to this pin, `false` if not.
     *
     */
    get connected(): boolean;
    /**
     *
     * Override this to determine the value of `.connected` through other means.
     *
     */
    protected isConnected(): boolean;
    /**
     *
     * Override this to determine if the pin is locked.
     * You can read more about this [here](https://connective.dev/docs/pin#subscribing-and-binding).
     *
     * @param observable
     *
     */
    protected abstract isLocked(observable: Observable<Emission> | undefined): boolean;
    /**
     *
     * Override this to determine if the underlying observable should be resolved, based on
     * inbound connected pins and the currently resolved observable.
     *
     * @param inbound
     * @param observable
     *
     */
    protected abstract shouldResolve(inbound: PinLike[], observable: Observable<Emission> | undefined): boolean;
    /**
     *
     * Override this to determine how the underlying observable should be resolved, based on
     * pins connected to this pin.
     *
     * @param inbound
     *
     */
    protected abstract resolve(inbound: PinLike[]): Observable<Emission>;
}
