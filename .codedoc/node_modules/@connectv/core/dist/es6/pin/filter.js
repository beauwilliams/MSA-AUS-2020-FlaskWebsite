import { Observable } from 'rxjs';
import { filter as _filter, map, mergeMap, share } from 'rxjs/operators';
import { EmissionError } from '../shared/errors/emission-error';
import { Pipe } from './pipe';
/**
 *
 * Represents [filter](https://connective.dev/docs/filter) pins.
 *
 */
export class Filter extends Pipe {
    constructor(_func) {
        super((_func.length <= 1) ?
            ([_filter(emission => {
                    try {
                        return _func(emission.value);
                    }
                    catch (error) {
                        throw new EmissionError(error, emission);
                    }
                })]) :
            ([
                mergeMap(emission => new Observable(subscriber => {
                    _func(emission.value, (res) => {
                        subscriber.next(res);
                        subscriber.complete();
                    }, (error) => {
                        subscriber.error(new EmissionError(error, emission));
                    }, emission.context);
                })
                    .pipe(_filter(_ => !!_), map(_ => emission))),
                share()
            ]));
        this.filter = _func;
    }
}
/**
 *
 * Creates a [filter](https://connective.dev/docs/filter) pin using given predicate.
 * A filter pin will pass some values through and not others based on given predicate.
 * [Checkout the docs](https://connective.dev/docs/filter) for examples and further information.
 *
 * @param filter
 *
 */
export function filter(filter) { return new Filter(filter); }
/**
 *
 * Creates a [filter](https://connective.dev/docs/filter) that never allows any value through.
 *
 */
export function block() { return new Filter(() => false); }
export default filter;
//# sourceMappingURL=filter.js.map