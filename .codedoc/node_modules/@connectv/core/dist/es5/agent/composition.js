"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var bindable_1 = require("../shared/bindable");
var agent_1 = require("./agent");
var child_not_defined_error_1 = require("./errors/child-not-defined.error");
var child_type_mismatch_error_1 = require("./errors/child-type-mismatch.error");
/**
 *
 * Represents [compositions](https://connective.dev/docs/composition). This class
 * is to be used directly if you want to create class-based compositions, otherwise
 * utilize [`composition()`](https://connective.dev/docs/composition) method.
 *
 */
var Composition = /** @class */ (function (_super) {
    __extends(Composition, _super);
    /**
     *
     * @param signature the signature of the composition
     *
     */
    function Composition(signature) {
        var _this = _super.call(this, signature) || this;
        _this.init();
        return _this;
    }
    /**
     *
     * Override this to modify the initialization process of a composition.
     * This function is called by parent's constructor, so if you want to
     * invoke `.build()` and `.wire()` after some child-class properties have been
     * initialized as well, you would need to override this function. This is a typical
     * scenario in case of parametric class-based compositions.
     *
     */
    Composition.prototype.init = function () {
        this.build();
        this.wire();
    };
    /**
     *
     * Adds a child (pin or agent) to the composition. You can provide a name. If not,
     * the child will be named numerically based on the length of the children already added:
     *
     * ```typescript
     * build() {
     *   this.add('myState', state());
     *   this.add(expr((x, y) => x * y));
     * }
     *
     * wire() {
     *   this.agent('myState'); // --> this is the defined state
     *   this.agent(1);         // --> this is the defined expr
     * }
     * ```
     *
     * @param nameOrChild
     * @param child
     *
     */
    Composition.prototype.add = function (nameOrChild, child) {
        if (!this._children)
            this._children = {};
        if (!child)
            return this.add("" + Object.keys(this._children).length, nameOrChild);
        var _name = nameOrChild;
        this._children[_name] = child;
        if (bindable_1.isBindable(child))
            this.toBind(child);
        return child;
    };
    /**
     *
     * @param name
     * @returns the child with given name.
     * @throws an error if no child with given name is defined.
     *
     */
    Composition.prototype.child = function (name) {
        if (typeof name !== 'string')
            return this.child(name.toString());
        if (this._children && name in this._children)
            return this._children[name];
        throw new child_not_defined_error_1.ChildNotDefined(name);
    };
    /**
     *
     * @param name
     * @returns the pin child with given name.
     * @throws an error if no child with given name is defined or if it is not a pin.
     *
     */
    Composition.prototype.pin = function (name) {
        var _child = this.child(name);
        if (_child instanceof agent_1.Agent)
            throw new child_type_mismatch_error_1.ChildIsNotPin(name.toString());
        return _child;
    };
    /**
     *
     * @param name
     * @returns the child agent with given name.
     * @throws an error if no child with given name is defined or if it is not an agent.
     *
     */
    Composition.prototype.agent = function (name) {
        var _child = this.child(name);
        if (!(_child instanceof agent_1.Agent))
            throw new child_type_mismatch_error_1.ChildIsNotAgent(name.toString());
        return _child;
    };
    /**
     *
     * Registers a `Bindable` that will be bound when `.bind()` is called on this composition.
     *
     * @param bindable
     *
     */
    Composition.prototype.toBind = function (bindable) {
        if (!this._bindables)
            this._bindables = [];
        this._bindables.push(bindable);
        return this;
    };
    /**
     *
     * Binds all registered `Bindable`s, including bindable children like
     * [states](https://connective.dev/docs/state) and
     * [sinks](https://connective.dev/docs/sink).
     *
     */
    Composition.prototype.bind = function () {
        if (this._bindables)
            this._bindables.forEach(function (bindable) { return bindable.bind(); });
        return this;
    };
    /**
     *
     * @note `.clear()` on `Composition` also clears all registered children.
     *
     */
    Composition.prototype.clear = function () {
        if (this._children) {
            Object.values(this._children).forEach(function (child) { return child.clear(); });
            this._children = undefined;
        }
        if (this._bindables)
            this._bindables = undefined;
        return _super.prototype.clear.call(this);
    };
    return Composition;
}(agent_1.Agent));
exports.Composition = Composition;
//# sourceMappingURL=composition.js.map