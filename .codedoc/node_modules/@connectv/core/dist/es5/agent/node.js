"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var control_1 = __importDefault(require("../pin/control"));
var pack_1 = __importDefault(require("../pin/pack"));
var filter_1 = __importDefault(require("../pin/filter"));
var map_1 = __importDefault(require("../pin/map"));
var signature_mismatch_error_1 = require("./errors/signature-mismatch.error");
var insufficient_input_error_1 = require("./errors/insufficient-input.error");
var agent_1 = require("./agent");
/**
 *
 * Represents a [node](https://connective.dev/docs/node).
 *
 */
var Node = /** @class */ (function (_super) {
    __extends(Node, _super);
    /**
     *
     * @param signature the [signature](https://connective.dev/docs/agent#signature) of the node.
     *
     */
    function Node(signature) {
        var _this = _super.call(this, signature) || this;
        _this._control_required = true;
        _this._control = control_1.default();
        _this._res =
            pack_1.default(_this.inputs, _this.control.to(map_1.default(function () { return _this._control_required = false; })))
                .to(filter_1.default(function () { return !_this._control_required; }))
                .to(map_1.default(function (all, callback, error, context) {
                if (_this._control.connected)
                    _this._control_required = true;
                if (signature.required && signature.required.some(function (label) { return !(all && all[0] && label in all[0]); }))
                    error(new insufficient_input_error_1.InsufficientInputs(signature.required.filter(function (label) { return !(all && all[0] && label in all[0]); })));
                else {
                    _this.run(all[0], function (out, data) {
                        if (!_this.signature.outputs.includes(out)) {
                            error(new signature_mismatch_error_1.OutputNotInSignature(out, _this.signature));
                        }
                        else {
                            callback({ out: out, data: data });
                        }
                    }, error, context);
                }
            }));
        return _this;
    }
    Object.defineProperty(Node.prototype, "control", {
        /**
         *
         * A node waits for its `.control` before each execution, if any pins are
         * connected to `.control`.
         *
         */
        get: function () { return this._control; },
        enumerable: true,
        configurable: true
    });
    Node.prototype.createOutput = function (label) {
        this.checkOutput(label);
        return this._res
            .to(filter_1.default(function (res) { return res.out == label; }))
            .to(map_1.default(function (res) { return res.data; }));
    };
    Node.prototype.createEntries = function () {
        var _this = this;
        return (this.signature.inputs || []).map(function (i) { return _this.in(i); });
    };
    Node.prototype.createExits = function () {
        var _this = this;
        return this.signature.outputs.map(function (o) { return _this.out(o); });
    };
    Node.prototype.clear = function () {
        this.control.clear();
        return _super.prototype.clear.call(this);
    };
    return Node;
}(agent_1.Agent));
exports.Node = Node;
var _CodeNode = /** @class */ (function (_super) {
    __extends(_CodeNode, _super);
    function _CodeNode(signature, _run) {
        var _this = _super.call(this, signature) || this;
        _this._run = _run;
        return _this;
    }
    _CodeNode.prototype.run = function (inputs, output, error, context) { this._run.apply(this, [inputs, output, error, context]); };
    ;
    return _CodeNode;
}(Node));
/**
 *
 * Creates a [node](https://connective.dev/docs/node).
 * [Checkout the docs](https://connective.dev/docs/node) for examples and further information.
 *
 * @param signature the signature of the node
 * @param run the execution function of the node
 *
 */
function node(signature, run) { return function () { return new _CodeNode(signature, run); }; }
exports.node = node;
exports.default = node;
//# sourceMappingURL=node.js.map