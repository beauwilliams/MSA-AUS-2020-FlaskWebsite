"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var operators_1 = require("rxjs/operators");
var emission_1 = require("../shared/emission");
var group_1 = __importDefault(require("../pin/group"));
var pin_1 = __importDefault(require("../pin/pin"));
var source_1 = require("../pin/source");
var filter_1 = require("../pin/filter");
var pipe_1 = __importDefault(require("../pin/pipe"));
var agent_1 = require("./agent");
/**
 *
 * Represents [join](https://connective.dev/docs/join) agents.
 *
 */
var Join = /** @class */ (function (_super) {
    __extends(Join, _super);
    /**
     *
     * @param keys the keys of the joined object
     * @param pop should it pop the fork tag or not? Default is `true`
     *
     */
    function Join(keys, pop) {
        if (pop === void 0) { pop = true; }
        var _this = _super.call(this, {
            inputs: keys,
            outputs: ['output']
        }) || this;
        _this.keys = keys;
        _this.pop = pop;
        _this._cache = {};
        _this._inject = new source_1.Source();
        return _this;
    }
    Join.prototype._receive = function (key, emission) {
        var _this = this;
        if (emission.context.__fork) {
            if (emission.context.__fork instanceof emission_1.MergedEmissionContextVal)
                emission.context.__fork.values.forEach(function (v) { return _this._fill(v, key, emission); });
            else
                this._fill(emission.context.__fork, key, emission);
        }
        else
            this._fill([], key, emission);
    };
    Join.prototype._cache_key = function (fork) { return fork.join(';'); };
    Join.prototype._fill = function (fork, key, emission) {
        var _fork = this._cache_key(fork);
        var _cache = this._cache[_fork] = this._cache[_fork] || {};
        _cache[key] = emission;
        if (this._complete(_cache))
            this._emit(_cache, fork);
    };
    Join.prototype._emit = function (cache, fork) {
        delete this._cache[this._cache_key(fork)];
        var emission = emission_1.Emission.from(Object.values(cache), Object.entries(cache).reduce(function (obj, entry) {
            obj[entry[0]] = entry[1].value;
            return obj;
        }, {}));
        emission.context.__fork = this.pop ? fork.slice(0, -1) : __spreadArrays(fork);
        this._inject.emit(emission);
    };
    Join.prototype._complete = function (cache) {
        return Object.values(cache).length == this.keys.length;
    };
    Join.prototype.createOutput = function (label) {
        var _this = this;
        this.checkOutput(label);
        return group_1.default(group_1.default.apply(void 0, this.keys.map(function (key) { return _this.in(key).to(pipe_1.default(operators_1.tap(function (e) { return _this._receive(key, e); }))); })).to(filter_1.block()), this._inject).to(pin_1.default());
    };
    Join.prototype.createEntries = function () {
        var _this = this;
        return this.keys.map(function (key) { return _this.in(key); });
    };
    Join.prototype.createExits = function () { return [this.output]; };
    Object.defineProperty(Join.prototype, "output", {
        /**
         *
         * Shortcut for `.out('output')`, which will emit the joined object.
         * [Read this](https://connective.dev/docs/handle-error#signature) for more details.
         *
         */
        get: function () { return this.out('output'); },
        enumerable: true,
        configurable: true
    });
    Join.prototype.clear = function () {
        this._inject.clear();
        this._cache = {};
        return this;
    };
    return Join;
}(agent_1.Agent));
exports.Join = Join;
/**
 *
 * Creates a [join](https://connective.dev/docs/join) agent. Join agents
 * will re-join values created from the same forked emission in parallel, creating
 * a joined object with given keys.
 * [Checkout the docs](https://connective.dev/docs/join) for examples and further information.
 *
 * @param keys the keys of the joined object. An input will be created per key.
 *
 */
function join() {
    var keys = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        keys[_i] = arguments[_i];
    }
    return new Join(keys);
}
exports.join = join;
/**
 *
 * Creates a [join](https://connective.dev/join) agent that does not pop
 * the fork tag upon joining.
 * [Checkout the docs](https://connective.dev/docs/join) for examples and further information.
 *
 * @param keys the keys of the joined object. An input will be created per key.
 */
function peekJoin() {
    var keys = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        keys[_i] = arguments[_i];
    }
    return new Join(keys, false);
}
exports.peekJoin = peekJoin;
exports.default = join;
//# sourceMappingURL=join.js.map