"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var rxjs_1 = require("rxjs");
var control_1 = __importStar(require("../pin/control"));
var map_1 = __importDefault(require("../pin/map"));
var filter_1 = __importDefault(require("../pin/filter"));
var pack_1 = __importDefault(require("../pin/pack"));
var agent_1 = require("./agent");
var call_1 = require("./call");
/**
 *
 * Represents [invoke](https://connective.dev/docs/invoke) agents.
 *
 */
var Invoke = /** @class */ (function (_super) {
    __extends(Invoke, _super);
    /**
     *
     * @param ref the agent factory to be used in response to each set of incoming data
     * @param signature an optional signature denoting the signature of the agents that
     * are to be created. If not provided and not directly deducable from the factory function itself,
     * the factory function will be invoked once to deduce the signature.
     *
     */
    function Invoke(ref, signature) {
        var _this = _super.call(this, signature || ref.signature || ref().clear().signature) || this;
        _this.ref = ref;
        _this._all_subs = new rxjs_1.Subscription();
        _this._control_required = true;
        _this._control = new control_1.Control();
        _this._relay = pack_1.default(control_1.default(_this.inputs), _this._control.to(map_1.default(function () { return _this._control_required = false; })))
            .to(filter_1.default(function () { return !_this._control_required; }))
            .to(map_1.default(function (_) {
            if (_this._control.connected)
                _this._control_required = true;
            return _[0];
        }))
            .to(call_1.exec(_this.ref, function (s) { return _this._all_subs.add(s); }, function (s) { return _this._all_subs.remove(s); }, function () { return _this.outputs.entries.map(function (_a) {
            var label = _a[0], _ = _a[1];
            return label;
        }); }));
        return _this;
    }
    Invoke.prototype.createOutput = function (label) {
        this.checkOutput(label);
        return this._relay
            .to(filter_1.default(function (data) { return data.label == label; }))
            .to(map_1.default(function (data) { return data.value; }));
    };
    Invoke.prototype.createEntries = function () {
        var _this = this;
        return (this.signature.inputs || []).map(function (i) { return _this.in(i); });
    };
    Invoke.prototype.createExits = function () {
        var _this = this;
        return this.signature.outputs.map(function (o) { return _this.out(o); });
    };
    Object.defineProperty(Invoke.prototype, "control", {
        /**
         *
         * You can control when the agent creates the inner-agent and runs it on latest set of
         * incoming values by emitting to `.control`.
         *
         */
        get: function () { return this._control; },
        enumerable: true,
        configurable: true
    });
    Invoke.prototype.clear = function () {
        this._relay.clear();
        this._control.clear();
        this._all_subs.unsubscribe();
        return _super.prototype.clear.call(this);
    };
    return Invoke;
}(agent_1.Agent));
exports.Invoke = Invoke;
/**
 *
 * Creates an [invoke](https://connective.dev/docs/invoke) agent. Invoke
 * agents create an inner-agent using the given factory in response to each set of incoming inputs
 * and emit the first output of the inner-agent in response.
 * [Checkout the docs](https://connective.dev/docs/invoke) for examples and further information.
 *
 * @param ref the agent factory to be used to create inner-agents
 * @param signature the signature of the inner-agents. If not provided and not deducable from
 * the factory function, the factory function will be invoked once to deduce this.
 *
 */
function invoke(ref, signature) { return new Invoke(ref, signature); }
exports.invoke = invoke;
exports.default = invoke;
//# sourceMappingURL=invoke.js.map