"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var control_1 = __importDefault(require("../pin/control"));
var pack_1 = __importDefault(require("../pin/pack"));
var map_1 = __importDefault(require("../pin/map"));
var filter_1 = __importDefault(require("../pin/filter"));
var agent_1 = require("./agent");
var node_1 = require("./node");
/**
 *
 * A class to wrap an agent so that it behaves like a [node](https://connective.dev/docs/node).
 *
 */
var NodeWrap = /** @class */ (function (_super) {
    __extends(NodeWrap, _super);
    /**
     *
     * @param core the original agent to be wrapped.
     *
     */
    function NodeWrap(core) {
        var _this = _super.call(this, core.signature) || this;
        _this.core = core;
        _this._control_required = true;
        _this._control = control_1.default();
        _this._pack = pack_1.default(_this.inputs, _this._control.to(map_1.default(function () { return _this._control_required = false; })))
            .to(filter_1.default(function () { return !_this._control_required; }))
            .to(map_1.default(function (all) {
            if (_this._control.connected)
                _this._control_required = true;
            return all[0];
        }));
        _this.track(core.inputs.subscribe(function (label, pin) {
            _this._pack.to(map_1.default(function (all) { return all[label]; })).to(pin);
        }));
        _this.track(core.outputs.subscribe(function (label, pin) {
            pin.to(_this.out(label));
        }));
        return _this;
    }
    Object.defineProperty(NodeWrap.prototype, "control", {
        get: function () { return this._control; },
        enumerable: true,
        configurable: true
    });
    NodeWrap.prototype.createInput = function (label) {
        this.core.in(label);
        return _super.prototype.createInput.call(this, label);
    };
    NodeWrap.prototype.createOutput = function (label) {
        this.core.out(label);
        return _super.prototype.createOutput.call(this, label);
    };
    NodeWrap.prototype.clear = function () {
        this._control.clear();
        this._pack.clear();
        this.core.clear();
        return _super.prototype.clear.call(this);
    };
    return NodeWrap;
}(agent_1.Agent));
exports.NodeWrap = NodeWrap;
/**
 *
 * Wraps given agent in a `NodeWrap`, making it behave like a
 * [node](https://connective.dev/docs/node):
 *
 * - It will wait for all of its inputs to emit at least once before first execution
 * - Re-executes any time a new value is emitted from any of the inputs
 * - Waits for its `.control` if its connected before each execution
 * - Responds with the first output of the wrapped agent for each execution
 *
 * @param agent
 *
 */
function nodeWrap(agent) {
    if (agent instanceof node_1.Node)
        return agent;
    return new NodeWrap(agent);
}
exports.nodeWrap = nodeWrap;
exports.default = nodeWrap;
//# sourceMappingURL=node-wrap.js.map