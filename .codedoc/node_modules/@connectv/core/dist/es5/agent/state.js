"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var lodash_isequal_1 = __importDefault(require("lodash.isequal"));
var rxjs_1 = require("rxjs");
var emission_1 = require("../shared/emission");
var group_1 = __importDefault(require("../pin/group"));
var source_1 = __importDefault(require("../pin/source"));
var filter_1 = __importDefault(require("../pin/filter"));
var agent_1 = require("./agent");
var _Unset = {};
/**
 *
 * Represents [state](https://connective.dev/docs/state) agents.
 *
 */
var State = /** @class */ (function (_super) {
    __extends(State, _super);
    /**
     *
     * @param initialOrCompare either initial value or equality function
     * @param compare the equality function, if provided the first parameter must be the initial value.
     */
    function State(initialOrCompare, compare) {
        if (initialOrCompare === void 0) { initialOrCompare = _Unset; }
        var _this = _super.call(this, {
            inputs: ['value'],
            outputs: ['value']
        }) || this;
        /**
         *
         * The initial value of the agent
         *
         */
        _this.initial = _Unset;
        if (initialOrCompare == _Unset && !compare) {
            _this.initial = _Unset;
            _this.compare = lodash_isequal_1.default;
        }
        else if (compare) {
            _this.initial = initialOrCompare;
            _this.compare = compare;
        }
        else {
            if (typeof initialOrCompare === 'function')
                _this.compare = initialOrCompare;
            else {
                _this.initial = initialOrCompare;
                _this.compare = lodash_isequal_1.default;
            }
        }
        _this._subject = new rxjs_1.BehaviorSubject(emission_1.emission(_this.initial));
        _this._injector = source_1.default();
        return _this;
    }
    Object.defineProperty(State.prototype, "input", {
        /**
         *
         * Shortcut for `.in('value')`, on which the state receives new values.
         * [Read this](https://connective.dev/docs/state#signature) for more details.
         *
         */
        get: function () { return this.in('value'); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(State.prototype, "output", {
        /**
         *
         * Shortcut for `.out('value')`, on which the state emits new values.
         * [Read this](https://connective.dev/docs/state#signature) for more details.
         *
         */
        get: function () { return this.out('value'); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(State.prototype, "value", {
        /**
         *
         * Allows reading or updating `State`'s value directly. It will be equal
         * to the latest value emitted by the `State`, and setting it, if the value
         * has changed truly, will cause the `State` to emit the new value.
         *
         */
        get: function () { return (this._subject.value.value !== _Unset) ? (this._subject.value.value) : undefined; },
        set: function (v) { this._injector.send(v); },
        enumerable: true,
        configurable: true
    });
    /**
     *
     * Causes the agent to start receiving values even
     * without any subscribers.
     *
     */
    State.prototype.bind = function () {
        this.track(this.output.observable.subscribe());
        return this;
    };
    /**
     *
     * @note `State`'s `.clear()` also causes a complete
     * notification to be sent to observers.
     *
     */
    State.prototype.clear = function () {
        this._subject.complete();
        return _super.prototype.clear.call(this);
    };
    State.prototype.createOutput = function (_) {
        var _this = this;
        this.checkOutput(_);
        return group_1.default(this.input, this._injector)
            .to(filter_1.default(function (v) { return !_this.compare(v, _this.value); }))
            .to(source_1.default(this._subject))
            .to(filter_1.default(function (v) { return v !== _Unset; }));
    };
    State.prototype.createEntries = function () { return [this.input]; };
    State.prototype.createExits = function () { return [this.output]; };
    return State;
}(agent_1.Agent));
exports.State = State;
/**
 *
 * Creates a [state](https://connective.dev/docs/state) agent.
 * State agents can hold state in a reactive flow.
 * [Checkout the docs](https://connective.dev/docs/state) for examples and further information.
 *
 * @param initialOrCompare the initial value or compare function
 * @param compare the equality function to be used to determine state change, in case initial value is provided
 *
 */
function state(initialOrCompare, compare) {
    return new State(initialOrCompare, compare);
}
exports.state = state;
exports.default = state;
//# sourceMappingURL=state.js.map