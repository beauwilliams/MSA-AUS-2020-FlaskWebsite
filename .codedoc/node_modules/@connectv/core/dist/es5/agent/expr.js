"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var node_1 = require("./node");
/**
 *
 * Represents [expression](https://connective.dev/docs/expr) agents.
 *
 */
var Expr = /** @class */ (function (_super) {
    __extends(Expr, _super);
    /**
     *
     * @param inputsOrFunc either a list of names for the inputs of the
     * [signature](https://connective.dev/docs/agent#signature) or the expr function
     * @param func the expr function (if this is provided, the first parameter must be alist of string)
     *
     */
    function Expr(inputsOrFunc, func) {
        var _this = _super.call(this, {
            inputs: (typeof inputsOrFunc === 'function') ? [] : inputsOrFunc,
            required: (typeof inputsOrFunc === 'function') ? [] : inputsOrFunc,
            outputs: ['result']
        }) || this;
        _this.func = func ? func : inputsOrFunc;
        return _this;
    }
    Expr.prototype.run = function (inputs, output, error, context) {
        var _ilist = this.signature.inputs ? this.signature.inputs.map(function (i) { return inputs[i]; }) : [];
        try {
            var val = this.func.apply(undefined, _ilist.concat(context));
            if (typeof val === 'function')
                val.apply(undefined, [function (out) { return output('result', out); }, error]);
            else
                output('result', val);
        }
        catch (err) {
            error(err);
        }
    };
    Object.defineProperty(Expr.prototype, "result", {
        /**
         *
         * Shortcut for `.out('result')`. The result of the evaluation of the
         * expression will be emitted via this output.
         *
         */
        get: function () { return this.out('result'); },
        enumerable: true,
        configurable: true
    });
    return Expr;
}(node_1.Node));
exports.Expr = Expr;
/**
 *
 * Creates an [expr](https://connective.dev/docs/expr) agent.
 * Expr agents turn a function into an agent.
 * [Checkout the docs](https://connective.dev/docs/expr) for examples and further information.
 *
 * @param inputsOrFunc either a list of names for the inputs of the signature or the function to convert
 * @param func the function to convert (if provided, the first argument must be a list of strings)
 *
 */
function expr(inputsOrFunc, func) {
    if (func)
        return new Expr(inputsOrFunc, func);
    else {
        var func_1 = inputsOrFunc;
        return new Expr(Array.apply(0, { length: func_1.length }).map(function (_, i) { return i.toString(); }), func_1);
    }
}
exports.expr = expr;
exports.default = expr;
//# sourceMappingURL=expr.js.map