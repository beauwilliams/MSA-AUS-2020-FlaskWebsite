"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var rxjs_1 = require("rxjs");
var base_1 = require("./base");
var locked_error_1 = require("./errors/locked.error");
var unresolved_observable_error_1 = require("./errors/unresolved-observable.error");
/**
 *
 * Represents pins that you can connect other pins to.
 *
 */
var Connectible = /** @class */ (function (_super) {
    __extends(Connectible, _super);
    function Connectible() {
        var _this = _super.call(this) || this;
        _this._resolving = false;
        _this._deference_connected = false;
        _this._inbound = [];
        return _this;
    }
    /**
     *
     * @note it will throw an error if this pin is already locked.
     * You can read more about this [here](https://connective.dev/docs/pin#subscribing-and-binding).
     *
     */
    Connectible.prototype.connect = function (pin) {
        if (this.locked)
            throw new locked_error_1.PinLockedError();
        if (!this._inbound.includes(pin))
            this._inbound.push(pin);
        return this;
    };
    Object.defineProperty(Connectible.prototype, "observable", {
        /**
         *
         * @note Accessing this property locks the pin.
         * You can read more about this [here](https://connective.dev/docs/pin#subscribing-and-binding).
         *
         */
        get: function () {
            var _this = this;
            if (this.shouldResolve(this._inbound, this._observable)) {
                if (this._resolving) {
                    if (!this._deferred) {
                        this._deferred = new rxjs_1.Subject();
                    }
                    return this._deferred;
                }
                else {
                    this._resolving = true;
                    this._observable = this.resolve(this._inbound);
                    if (this._deferred) {
                        var _pristine_1 = this._observable;
                        this._observable = rxjs_1.defer(function () {
                            if (!_this._deference_connected) {
                                _this.track(_pristine_1.subscribe(_this._deferred));
                                _this._deference_connected = true;
                            }
                            return _pristine_1;
                        });
                    }
                    this._resolving = false;
                }
            }
            if (!this._observable)
                throw new unresolved_observable_error_1.UnresolvedPinObservableError();
            return this._observable;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     * @note Calling `.clear()` will unlock the pin and disconnect it from
     * all the pins its connected to (removing their references). There is no guarantee
     * that the pin will be usable afterwards.
     *
     */
    Connectible.prototype.clear = function () {
        this._inbound.length = 0;
        this._observable = undefined;
        this._deference_connected = false;
        if (this._deferred) {
            this._deferred.complete();
            this._deferred = undefined;
        }
        return _super.prototype.clear.call(this);
    };
    Object.defineProperty(Connectible.prototype, "locked", {
        /**
         *
         * @returns `true` if the pin is locked, `false` if not.
         * You can read more about this [here](https://connective.dev/docs/pin#subscribing-and-binding).
         *
         */
        get: function () { return this.isLocked(this._observable); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Connectible.prototype, "connected", {
        /**
         *
         * @returns `true` if any other pin is connected to this pin, `false` if not.
         *
         */
        get: function () { return this.isConnected(); },
        enumerable: true,
        configurable: true
    });
    /**
     *
     * Override this to determine the value of `.connected` through other means.
     *
     */
    Connectible.prototype.isConnected = function () { return this._inbound.length > 0; };
    return Connectible;
}(base_1.BasePin));
exports.Connectible = Connectible;
//# sourceMappingURL=connectible.js.map