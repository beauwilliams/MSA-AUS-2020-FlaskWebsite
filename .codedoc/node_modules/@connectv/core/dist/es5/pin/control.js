"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var rxjs_1 = require("rxjs");
var operators_1 = require("rxjs/operators");
var emission_1 = __importStar(require("../shared/emission"));
var pin_1 = require("./pin");
var pin_map_1 = require("./pin-map");
var _UNSET = {};
/**
 *
 * Represents [control](https://connective.dev/docs/control) pins.
 *
 */
var Control = /** @class */ (function (_super) {
    __extends(Control, _super);
    function Control(val) {
        if (val === void 0) { val = _UNSET; }
        var _this = _super.call(this) || this;
        _this.val = val;
        return _this;
    }
    /**
     *
     * Resolves underlying observable, by
     * [zipping](https://rxjs-dev.firebaseapp.com/api/index/function/zip)
     * corresponding observables of inbound pins.
     *
     * If a `PinMap` is passed to the constructor, it will instead
     * resolve to zip of all of the instantiated pins of that `PinMap`.
     *
     * If a value is passed to the constructor, and there are no inbound
     * pins, it will resolve to `of(<passed value>)`.
     *
     * @param inbound
     *
     */
    Control.prototype.resolve = function (inbound) {
        var _this = this;
        if (this.val instanceof pin_map_1.PinMap) {
            var _entries_1 = this.val.entries;
            if (_entries_1.length == 0)
                return rxjs_1.of(emission_1.default());
            return rxjs_1.zip.apply(void 0, _entries_1.map(function (entry) { return entry[1].observable; })).pipe(operators_1.map(function (emissions) { return emission_1.Emission.from(emissions, _entries_1.reduce(function (_map, entry, index) {
                _map[entry[0]] = emissions[index].value;
                return _map;
            }, {})); }));
        }
        else if (inbound.length == 0)
            return rxjs_1.of(emission_1.default(this.val));
        else {
            var _zipped = rxjs_1.zip.apply(void 0, inbound.map(function (pin) { return pin.observable; }));
            if (this.val !== _UNSET)
                return _zipped.pipe(operators_1.map(function (emissions) { return emission_1.Emission.from(emissions, _this.val); }));
            else
                return _zipped.pipe(operators_1.map(function (emissions) { return emission_1.Emission.from(emissions); }));
        }
        ;
    };
    return Control;
}(pin_1.Pin));
exports.Control = Control;
/**
 *
 * Creates a [control](https://connective.dev/docs/control) pin.
 *
 * @param val if provided, the control pin will emit the given value when
 * all pins connected to it emit, otherwise it will emit the array concatenation
 * of received values. If no pins are connected to it, then it will emit the value
 * to any subscriber (or to any pin that this pin is connected to, when a subscription
 * is called somwhere down the chain).
 *
 * If a `PinMap` is given as the value, then after resolution, the control will be
 * connected to all "realised" pins of the given pinmap.
 *
 */
function control(val) { return new Control(val); }
exports.control = control;
exports.default = control;
//# sourceMappingURL=control.js.map