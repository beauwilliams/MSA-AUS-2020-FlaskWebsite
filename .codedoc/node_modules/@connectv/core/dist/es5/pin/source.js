"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var rxjs_1 = require("rxjs");
var emission_1 = __importDefault(require("../shared/emission"));
var connectible_1 = require("./connectible");
/**
 *
 * Represents [source](https://connective.dev/docs/source) pins.
 *
 */
var Source = /** @class */ (function (_super) {
    __extends(Source, _super);
    function Source(_subject) {
        if (_subject === void 0) { _subject = new rxjs_1.Subject(); }
        var _this = _super.call(this) || this;
        _this._subject = _subject;
        return _this;
    }
    /**
     *
     * This source will send given value, perhaps with given context.
     * Will create a new [emission](https://connective.dev/docs/emission) object.
     *
     * @param value the value to send
     * @param context the emission context
     *
     */
    Source.prototype.send = function (value, context) {
        this.emit(emission_1.default(value, context));
    };
    /**
     *
     * Will emit the given emission object.
     *
     * @param emission
     *
     */
    Source.prototype.emit = function (emission) {
        this._subject.next(emission);
    };
    /**
     *
     * @note this sends a complete notification through-out the flow.
     * Pins that are merely reliant on this source will also be unusable
     * afterwards.
     *
     */
    Source.prototype.clear = function () {
        this._subject.complete();
        this._subject = new rxjs_1.Subject();
        return _super.prototype.clear.call(this);
    };
    /**
     *
     * Determines if any pin is connected to this pin.
     *
     */
    Source.prototype.isConnected = function () {
        return this.tracking || _super.prototype.isConnected.call(this);
    };
    /**
     *
     * Resolves the underlying observable of this pin by subscribing the
     * subject of this pin to all inbound pins.
     *
     * @param inbound
     *
     */
    Source.prototype.resolve = function (inbound) {
        var _this = this;
        inbound.forEach(function (pin) {
            _this.track(pin.observable.subscribe(_this._subject));
        });
        inbound.length = 0;
        return this._subject;
    };
    /**
     *
     * Determines whether this pin is locked. A source is never locked.
     *
     */
    Source.prototype.isLocked = function () { return false; };
    /**
     *
     * Determines whether should resolve the underlying observable.
     *
     * @param inbound
     * @param observable
     *
     */
    Source.prototype.shouldResolve = function (inbound, observable) {
        return inbound.length > 0 || !observable;
    };
    return Source;
}(connectible_1.Connectible));
exports.Source = Source;
/**
 *
 * Creates a [source](https://connective.dev/docs/source) pin.
 * A source pin can be used as the starting point of a reactive flow.
 * [Checkout the docs](https://connective.dev/docs/source) for examples and further information.
 *
 */
function source(sub) { return new Source(sub); }
exports.source = source;
exports.default = source;
//# sourceMappingURL=source.js.map