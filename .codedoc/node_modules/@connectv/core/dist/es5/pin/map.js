"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var rxjs_1 = require("rxjs");
var operators_1 = require("rxjs/operators");
var emission_error_1 = require("../shared/errors/emission-error");
var pipe_1 = require("./pipe");
/**
 *
 * Represents [map](https://connective.dev/docs/map) pins.
 *
 */
var Map = /** @class */ (function (_super) {
    __extends(Map, _super);
    function Map(_func) {
        var _this = _super.call(this, (_func.length <= 1) ?
            ([operators_1.map(function (emission) {
                    try {
                        return emission.fork(_func(emission.value));
                    }
                    catch (error) {
                        throw new emission_error_1.EmissionError(error, emission);
                    }
                })]) :
            ([
                operators_1.mergeMap(function (emission) {
                    return new rxjs_1.Observable(function (subscriber) {
                        _func(emission.value, function (res) {
                            subscriber.next(emission.fork(res));
                            subscriber.complete();
                        }, function (error) {
                            subscriber.error(new emission_error_1.EmissionError(error, emission));
                        }, emission.context);
                    });
                }),
                operators_1.share()
            ])) || this;
        _this.map = _func;
        return _this;
    }
    return Map;
}(pipe_1.Pipe));
exports.Map = Map;
/**
 *
 * Creates a [map](https://connective.dev/docs/map) pin using given transformation.
 * A map pin will transform incoming values based on given transformation.
 * [Checkout the docs](https://connective.dev/docs/map) for examples and further information.
 *
 * @param map
 *
 */
function map(map) { return new Map(map); }
exports.map = map;
exports.default = map;
//# sourceMappingURL=map.js.map