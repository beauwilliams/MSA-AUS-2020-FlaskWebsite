"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var rxjs_1 = require("rxjs");
var operators_1 = require("rxjs/operators");
var emission_1 = require("../shared/emission");
var emission_error_1 = require("../shared/errors/emission-error");
var pipe_1 = require("./pipe");
var _Unset = {};
//
// TODO: switch to concat map for async reducers
//
/**
 *
 * Represents [reduce](https://connective.dev/docs/reduce) pins.
 *
 */
var Reduce = /** @class */ (function (_super) {
    __extends(Reduce, _super);
    /**
     *
     * @param reduce is the reduction function
     * @param start is the start value
     *
     */
    function Reduce(reduce, start) {
        if (start === void 0) { start = _Unset; }
        var _this = _super.call(this, (reduce.length <= 2) ?
            ([operators_1.map(function (emission) {
                    if (!_this._acc) {
                        _this._acc = _this._init(emission, start);
                        if (start === _Unset)
                            return _this._acc;
                    }
                    _this._acc = emission_1.Emission.from([_this._acc, emission], reduce(_this._acc.value, emission.value));
                    return _this._acc;
                })]) :
            ([
                operators_1.mergeMap(function (emission) {
                    return new rxjs_1.Observable(function (subscriber) {
                        if (!_this._acc) {
                            _this._acc = _this._init(emission, start);
                            if (start === _Unset) {
                                subscriber.next(_this._acc);
                                subscriber.complete();
                                return;
                            }
                        }
                        reduce(_this._acc.value, emission.value, function (res) {
                            _this._acc = emission_1.Emission.from([_this._acc, emission], res);
                            subscriber.next(_this._acc);
                            subscriber.complete();
                        }, function (error) {
                            subscriber.error(new emission_error_1.EmissionError(error, emission));
                        }, emission.context, _this._acc.context);
                    });
                }),
                operators_1.share()
            ])) || this;
        _this.reduce = reduce;
        _this.start = start;
        _this._acc = undefined;
        return _this;
    }
    Reduce.prototype._init = function (emission, start) {
        if (start !== _Unset)
            return emission.fork(start);
        else
            return emission;
    };
    return Reduce;
}(pipe_1.Pipe));
exports.Reduce = Reduce;
/**
 *
 * Creates a [reduce](https://connective.dev/docs/reduce) pin.
 * A reduce pin can be used to aggregate values over multiple emissions, with an
 * aggregator function updating the aggregate value based on each incoming emission.
 * [Checkout the docs](https://connective.dev/docs/reduce) for examples and further information.
 *
 * @param reduce the reduction function
 * @param start the start value. If not provided, the value of first incoming emission will be used.
 *
 */
function reduce(reduce, start) {
    if (start === void 0) { start = _Unset; }
    return new Reduce(reduce, start);
}
exports.reduce = reduce;
exports.default = reduce;
//# sourceMappingURL=reduce.js.map