"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var operators_1 = require("rxjs/operators");
var tracker_1 = require("../shared/tracker");
var group_1 = require("./group");
var partial_flow_1 = require("./partial-flow");
//
// TODO: write tests for this
//
/**
 *
 * The base class for [pins](https://connective.dev/docs/pin).
 *
 */
var BasePin = /** @class */ (function (_super) {
    __extends(BasePin, _super);
    function BasePin() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * Connects this pin to given pins. Will invoke `.from()` on the receiving pins.
     * If any `PartialFlow` is among the given pins, the connection will be made to all of
     * its entry pins (read more about partial flows [here](https://connective.dev/docs/agent#implicit-connection)).
     *
     * @param pins the pins to connect to
     * @returns a [group](https://connective.dev/docs/group) of the given pins. If any `PartialFlow`
     * was among the given pins, its exit pins added to the group.
     *
     */
    BasePin.prototype.to = function () {
        var _this = this;
        var pins = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            pins[_i] = arguments[_i];
        }
        pins.forEach(function (pin) { return pin.from(_this); });
        return group_1.traverseTo.apply(void 0, pins);
    };
    /**
     *
     * Connects all given pins to this pin, by calling `.connect()` on each of them.
     * If any `PartialFlow` is among given pins, the exit pins of the partial flow will be
     * connected to this pin
     * (read more about partial flows [here](https://connective.dev/docs/agent#implicit-connection)).
     *
     * @param pins the pins to be connected to this pin
     * @returns a [group](https://connective.dev/docs/group) of the given pins. If any `PartialFlow`
     * was among the given pins, its entry pins will be added to the group.
     *
     */
    BasePin.prototype.from = function () {
        var _this = this;
        var pins = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            pins[_i] = arguments[_i];
        }
        pins.forEach(function (pin) {
            if (pin instanceof group_1.Group)
                pin.pins.forEach(function (p) { return _this.connect(p); });
            else if (pin instanceof partial_flow_1.PartialFlow)
                pin.exits.pins.forEach(function (o) { return _this.connect(o); });
            else
                _this.connect(pin);
        });
        return group_1.traverseFrom.apply(void 0, pins);
    };
    /**
     *
     * Connectss to given pins. This is same as `.to()`, except that when a `PartialFlow`
     * is among the given pins, this pin will be connected only to its first entry pin
     * (read more about partial flows [here](https://connective.dev/docs/agent#implicit-connection)).
     *
     * @param pins pins to connect this pin to
     * @returns a [group](https://connective.dev/docs/group) of the given pins. If any `PartialFlow`
     * was among the given pins, its exit pins added to the group.
     *
     */
    BasePin.prototype.serialTo = function () {
        var _this = this;
        var pins = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            pins[_i] = arguments[_i];
        }
        pins.forEach(function (pin) {
            if (pin instanceof partial_flow_1.PartialFlow) {
                if (pin.entries.pins.length > 0)
                    pin.entries.pins[0].from(_this);
            }
            else
                pin.from(_this);
        });
        return group_1.traverseTo.apply(void 0, pins);
    };
    /**
     *
     * Connects given pins to this pin. This is same as `.from()`, except that when a `PartialFlow`
     * is among given pins, only its first exit pin will be connected to this pin
     * (read more about partial flows [here](https://connective.dev/docs/agent#implicit-connection)).
     *
     * @param pins pins to connect to this pin
     * @returns a [group](https://connective.dev/docs/group) of the given pins. If any `PartialFlow`
     * was among the given pins, its entry pins will be added to the group.
     *
     */
    BasePin.prototype.serialFrom = function () {
        var _this = this;
        var pins = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            pins[_i] = arguments[_i];
        }
        pins.forEach(function (pin) {
            if (pin instanceof partial_flow_1.PartialFlow) {
                if (pin.exits.pins.length > 0)
                    _this.connect(pin.exits.pins[0]);
            }
            else
                _this.connect(pin);
        });
        return group_1.traverseTo.apply(void 0, pins);
    };
    /**
     *
     * Subscribes given function or partial observer to the observable of this pin.
     * The subscriber will recieve the emitted values and not the emission object itself,
     * so if you need to access the emission (for example, to access its context),
     * use `.observable.subscribe()` instead.
     *
     * @param observerOrNext either an [observer object](https://github.com/ReactiveX/rxjs/blob/master/doc/observer.md),
     * or a callback handling incoming values.
     * @param error a callback handling incoming errors.
     * @param complete a callback that will be invoked when the underlying observable sequence completes, for example
     * when the sources are all cleared out.
     * @returns the subscription object. The pin itself will track this subscription and clear it out when
     * its `.clear()` is invoked. If you wish to unsubscribe the subscription earlier than the time you clear
     * the pin out, then hold a reference to it and also remove it from subscriptions tracked by the pin
     * using `.untrack()`.
     *
     */
    BasePin.prototype.subscribe = function (observerOrNext, error, complete) {
        if (error || complete)
            return this.track(this.observable.pipe(operators_1.map(function (e) { return e.value; })).subscribe(observerOrNext, error, complete));
        else
            return this.track(this.observable.pipe(operators_1.map(function (e) { return e.value; })).subscribe(observerOrNext));
    };
    return BasePin;
}(tracker_1.Tracker));
exports.BasePin = BasePin;
//# sourceMappingURL=base.js.map