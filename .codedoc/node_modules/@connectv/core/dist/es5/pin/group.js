"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var rxjs_1 = require("rxjs");
var bindable_1 = require("../shared/bindable");
var group_subscription_1 = require("./errors/group-subscription");
var partial_flow_1 = require("./partial-flow");
/**
 *
 * Represents [groups of pins](https://connective.dev/docs/group).
 *
 */
var Group = /** @class */ (function () {
    function Group(pins) {
        this.pins = pins;
    }
    Object.defineProperty(Group.prototype, "observable", {
        /**
         *
         * @warning accessing this will result in an error since groups do not have
         * underlying observables of their own.
         *
         */
        get: function () {
            throw new group_subscription_1.GroupObservableError();
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     * Connects all given pins to all pins in this group, so
     * `group(c, d).from(a, b)` means both `a` and `b` will be connected
     * to both `c` and `d`.
     *
     * If any `PartialFlow` is among given pins, all of the exit pins of the partial flow will be
     * connected to all of the pins of this group
     * (read more about partial flows [here](https://connective.dev/docs/agent#implicit-connection)).
     *
     * @param pins pins to be connected to pins of this group
     * @returns a [group](https://connective.dev/docs/group) of the given pins. If any `PartialFlow`
     * was among the given pins, its entry pins will be added to the group.
     *
     */
    Group.prototype.from = function () {
        var _this = this;
        var pins = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            pins[_i] = arguments[_i];
        }
        pins.forEach(function (pin) { return _this.pins.forEach(function (p) { return p.from(pin); }); });
        return traverseFrom.apply(void 0, pins);
    };
    /**
     *
     * Connects all pins of this group to all of the given pins, so
     * `group(a, b).to(c, d)` means both `a` and `b` will be connected to
     * both `c` and `d`.
     *
     * If any `PartialFlow` is among the given pins, all pins of the group will be connected to all of
     * its entry pins (read more about partial flows [here](https://connective.dev/docs/agent#implicit-connection)).
     *
     * @param pins the pins to connect pins of this group to
     * @returns a [group](https://connective.dev/docs/group) of the given pins. If any `PartialFlow`
     * was among the given pins, its exit pins added to the group.
     *
     */
    Group.prototype.to = function () {
        var _this = this;
        var pins = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            pins[_i] = arguments[_i];
        }
        pins.forEach(function (pin) { return _this.pins.forEach(function (p) { return p.to(pin); }); });
        return traverseTo.apply(void 0, pins);
    };
    /**
     *
     * Connects given pins serially to pins of this group, i.e. the first to the first,
     * second to the second, etc. If any `PartialFlow` is among the given pins, then
     * its exit pins will be connected serially to pins of this group
     * (read more about partial flows [here](https://connective.dev/docs/agent#implicit-connection)).
     * If a mixture of `PartialFlow`s and normal pins are given, the normal pins will
     * be connected to pins of this group serially without counting the partial flows, and the
     * partial flows will each be connected to pins of this group as described.
     *
     * @param pins pins to be connected to pins of this group serially.
     * @returns a [group](https://connective.dev/docs/group) of the given pins. If any `PartialFlow`
     * was among the given pins, its entry pins will be added to the group.
     *
     */
    Group.prototype.serialFrom = function () {
        var _this = this;
        var pins = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            pins[_i] = arguments[_i];
        }
        pins.filter(function (pin) { return pin instanceof partial_flow_1.PartialFlow; }).forEach(function (flow) {
            for (var i = 0; i < Math.min(_this.pins.length, flow.exits.pins.length); i++)
                _this.pins[i].from(flow.exits.pins[i]);
        });
        var purePins = pins.filter(function (p) { return !(p instanceof partial_flow_1.PartialFlow); });
        for (var i = 0; i < Math.min(this.pins.length, purePins.length); i++)
            this.pins[i].from(purePins[i]);
        return traverseFrom.apply(void 0, pins);
    };
    /**
     *
     * Connects pins of this group serially to given pins, i.e. first to the first,
     * second to the second, etc. If any `PartialFlow` is among the given pins, pins of
     * this group will be connected serially to its entries
     * (read more about partial flows [here](https://connective.dev/docs/agent#implicit-connection)).
     * If a mixture of `PartialFlow`s and normal pins are given, pins of this group will
     * be connected to the normal pins serially without counting the partial flows, and they
     * will be connected to the partial flows as described.
     *
     * @param pins pins that pins of this group should connect to serially.
     * @returns a [group](https://connective.dev/docs/group) of the given pins. If any `PartialFlow`
     * was among the given pins, its exit pins added to the group.
     *
     */
    Group.prototype.serialTo = function () {
        var _this = this;
        var pins = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            pins[_i] = arguments[_i];
        }
        pins.filter(function (pin) { return pin instanceof partial_flow_1.PartialFlow; }).forEach(function (flow) {
            for (var i = 0; i < Math.min(_this.pins.length, flow.entries.pins.length); i++)
                _this.pins[i].to(flow.entries.pins[i]);
        });
        var purePins = pins.filter(function (p) { return !(p instanceof partial_flow_1.PartialFlow); });
        for (var i = 0; i < Math.min(this.pins.length, purePins.length); i++)
            this.pins[i].to(purePins[i]);
        return traverseTo.apply(void 0, pins);
    };
    /**
     *
     * Calls `.clear()` on all pins of the group
     *
     */
    Group.prototype.clear = function () {
        this.pins.forEach(function (pin) { return pin.clear(); });
        return this;
    };
    /**
     *
     * Calls `.bind()` on all pins of the group
     *
     */
    Group.prototype.bind = function () {
        this.pins.forEach(function (pin) {
            if (bindable_1.isBindable(pin))
                pin.bind();
        });
        return this;
    };
    /**
     *
     * Subscribes given observer (or callback functions) to all pins of the group.
     *
     * @returns a composite subscription holding all of the subscriptions made.
     *
     */
    Group.prototype.subscribe = function (_, __, ___) {
        return this.pins.reduce(function (sub, pin) {
            sub.add(pin.subscribe(_, __, ___));
            return sub;
        }, new rxjs_1.Subscription());
    };
    return Group;
}());
exports.Group = Group;
/**
 *
 * Creates a [group of pins](https://connective.dev/docs/group) based on given pins.
 *
 * @param pins
 *
 */
function group() {
    var pins = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        pins[_i] = arguments[_i];
    }
    return new Group(pins);
}
exports.group = group;
/**
 *
 * Determines which pins should be considered if in a connection chain
 * we are connecting to the given pins. This is typically a `Group` consisting
 * of given pins, but if any `PartialFlow`s are among them, their exit pins are
 * added to the group instead.
 *
 * @param pins
 *
 */
function traverseTo() {
    var pins = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        pins[_i] = arguments[_i];
    }
    if (pins.length == 1) {
        var pin = pins[0];
        if (pin instanceof partial_flow_1.PartialFlow)
            return pin.exits;
        else
            return pin;
    }
    else
        return group.apply(void 0, pins.reduce(function (all, pin) {
            if (pin instanceof partial_flow_1.PartialFlow)
                return all.concat(pin.exits.pins);
            else
                return all.concat([pin]);
        }, []));
}
exports.traverseTo = traverseTo;
/**
 *
 * Determines which pins should be considered if in a connection chain
 * we are connecting from the given pins. This is typically a `Group` consisting
 * of given pins, but if any `PartialFlow`s are among them, their entry pins are
 * added to the group instead.
 *
 * @param pins
 *
 */
function traverseFrom() {
    var pins = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        pins[_i] = arguments[_i];
    }
    if (pins.length == 1) {
        var pin = pins[0];
        if (pin instanceof partial_flow_1.PartialFlow)
            return pin.entries;
        else
            return pin;
    }
    else
        return group.apply(void 0, pins.reduce(function (all, pin) {
            if (pin instanceof partial_flow_1.PartialFlow)
                return all.concat(pin.entries.pins);
            else
                return all.concat([pin]);
        }, []));
}
exports.traverseFrom = traverseFrom;
exports.default = group;
//# sourceMappingURL=group.js.map