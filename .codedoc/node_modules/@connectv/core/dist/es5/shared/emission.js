"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 *
 * When the same key appears in multiple [emissions](https://connective.dev/docs/emission),
 * with conflicting values, when the emissions are merged, the corresponding values are
 * stored within an instance of `MergedEmissionContextVal`. You can read these values using
 * `.values` property:
 *
 * ```typescript
 * myFlow.observable.subscribe(emission => {
 *  if (emission.context.someKey instanceof MergedEmissionContextVal)
 *    emission.context.someKey.values.forEach(value => handle(value));
 *  else
 *    handle(emission.context.someKey);
 * });
 * ```
 *
 */
var MergedEmissionContextVal = /** @class */ (function () {
    function MergedEmissionContextVal(values) {
        this.values = values;
    }
    return MergedEmissionContextVal;
}());
exports.MergedEmissionContextVal = MergedEmissionContextVal;
var _Unset = {};
/**
 *
 * Represents emissions passing through reactive flows.
 * mainly has a `.value` property, which is the value that this emission is wrapping,
 * and `.context` property, which is the context of the emission.
 *
 * [read more here](https://connective.dev/docs/emission).
 *
 */
var Emission = /** @class */ (function () {
    /**
     *
     * @param value the value of the emission
     * @param context the context of the emission
     *
     */
    function Emission(value, context) {
        if (value === void 0) { value = undefined; }
        if (context === void 0) { context = {}; }
        this.value = value;
        this.context = context;
    }
    /**
     *
     * Will create a merged emission from given emissions.
     *
     * @param emissions the emissions to merge
     * @param value the value to set on the forked emission (by default will be an array of the merged emissions' values).
     *
     */
    Emission.from = function (emissions, value) {
        if (value === void 0) { value = _Unset; }
        return new Emission((value === _Unset) ? (emissions.map(function (emission) { return emission.value; })) : (value), emissions.reduce(function (ctx, emission) {
            Object.entries(emission.context).forEach(function (_a) {
                var key = _a[0], value = _a[1];
                if (key in ctx) {
                    if (ctx[key] == value)
                        return ctx;
                    if (ctx[key] instanceof MergedEmissionContextVal) {
                        if (value instanceof MergedEmissionContextVal) {
                            ctx[key] = new MergedEmissionContextVal(ctx[key].values.concat(value.values.filter(function (v) { return !ctx[key].values.includes(v); })));
                        }
                        else {
                            if (!ctx[key].values.includes(value))
                                ctx[key].values.push(value);
                        }
                    }
                    else {
                        if (value instanceof MergedEmissionContextVal) {
                            if (value.values.includes(ctx[key]))
                                ctx[key] = value;
                            else
                                ctx[key] = new MergedEmissionContextVal([ctx[key]].concat(value.values));
                        }
                        else
                            ctx[key] = new MergedEmissionContextVal([ctx[key], value]);
                    }
                }
                else
                    ctx[key] = value;
            });
            return ctx;
        }, {}));
    };
    /**
     *
     * Creates a new `Emission` with the same context but the new value
     *
     * @param value
     *
     */
    Emission.prototype.fork = function (value) {
        return new Emission(value, this.context);
    };
    return Emission;
}());
exports.Emission = Emission;
/**
 *
 * Creates an emission with given value and context. You can feed this object to
 * your reactive flows using [`source()`](https://connective.dev/docs/source) for example:
 *
 * ```typescript
 * let a = source();
 * a.emit(emission(42, { reason: 'it is the ultimate answer' }));
 * ```
 *
 * @param value
 * @param context
 */
function emission(value, context) {
    return new Emission(value, context);
}
exports.emission = emission;
exports.default = emission;
//# sourceMappingURL=emission.js.map