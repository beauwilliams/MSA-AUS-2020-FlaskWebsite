"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var marked_1 = require("marked");
var inline_1 = require("./inline");
var defaults_1 = require("./defaults");
var unescape_1 = require("./util/unescape");
var Parser = /** @class */ (function () {
    function Parser(options) {
        this.tokens = [];
        this.slugger = new marked_1.Slugger();
        this.options = defaults_1.fill(options || {});
    }
    Parser.prototype.parse = function (tokens, renderer) {
        this.renderer = renderer;
        this.inline = new inline_1.InlineProcessor(tokens, renderer, this.options);
        this.inlineText = new marked_1.InlineLexer(tokens.links, {
            renderer: new marked_1.TextRenderer()
        });
        this.tokens = tokens.reverse();
        var res = renderer.create("fragment", null);
        while (this.next())
            renderer.render(this.tok()).on(res);
        return res;
    };
    Parser.prototype.next = function () {
        var _next = this.tokens.pop();
        if (_next)
            this.token = _next;
        return _next;
    };
    Parser.prototype.safeNext = function () {
        var _next = this.next();
        if (!_next) /* istanbul ignore next */
            throw new Error('Unexpected end of stream');
        return _next;
    };
    Parser.prototype.peek = function () {
        return this.tokens[this.tokens.length - 1];
    };
    Parser.prototype.parseText = function () {
        var body = this.token.text || '';
        while (this.peek().type === 'text') /* istanbul ignore next */
            body += '\n' + this.next().text;
        return this.inline.process(body);
    };
    Parser.prototype.tok = function () {
        var _this = this;
        var renderer = this.renderer;
        switch (this.token.type) {
            case 'space': return this.options.Space ? renderer.create(this.options.Space, null) : renderer.create("fragment", null);
            case 'hr': return renderer.create(this.options.Hr, null);
            case 'heading':
                var slug = this.slugger.slug(unescape_1.unescape(this.inlineText.output(this.token.text)));
                return renderer.create(this.options.Heading, { depth: this.token.depth, slug: slug }, this.inline.process(this.token.text));
            case 'code':
                return renderer.create(this.options.Code, { lang: this.token.lang || '' }, this.token.text);
            case 'table': {
                var header = this.token.header.map(function (cell, i) {
                    return renderer.create(_this.options.TableHeaderCell, { align: _this.token.align[i] }, _this.inline.process(cell));
                });
                var body = this.token.cells.map(function (row) {
                    return renderer.create(_this.options.TableRow, null, row.map(function (cell, j) { return renderer.create(_this.options.TableCell, { align: _this.token.align[j] }, _this.inline.process(cell)); }));
                });
                return renderer.create(this.options.Table, { header: header, body: body });
            }
            case 'blockquote_start': {
                var body = renderer.create("fragment", null);
                while (this.safeNext().type !== 'blockquote_end')
                    renderer.render(this.tok()).on(body);
                return renderer.create(this.options.BlockQuote, null, body);
            }
            case 'list_start': {
                var body = renderer.create("fragment", null);
                var ordered = this.token.ordered;
                while (this.safeNext().type !== 'list_end')
                    renderer.render(this.tok()).on(body);
                return renderer.create(this.options.List, { ordered: ordered }, body);
            }
            case 'list_item_start': {
                var body = renderer.create("fragment", null);
                var loose = this.token.loose;
                while (this.safeNext().type !== 'list_item_end') {
                    if (!loose && this.token.type === 'text')
                        renderer.render(renderer.create("fragment", null, this.parseText())).on(body);
                    else
                        renderer.render(this.tok()).on(body);
                }
                return renderer.create(this.options.ListItem, null, body);
            }
            case 'html':
                return renderer.create(this.options.Html, { content: this.token.text });
            case 'paragraph':
                return renderer.create(this.options.Paragraph, null, this.inline.process(this.token.text));
            case 'text':
                return renderer.create(this.options.Paragraph, null, this.parseText());
            default: /* istanbul ignore next */
                throw new Error('Unrecognized Token:: ' + this.token.type);
        }
    };
    return Parser;
}());
exports.Parser = Parser;
//# sourceMappingURL=parser.js.map