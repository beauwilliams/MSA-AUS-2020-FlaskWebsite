{"version":3,"file":"parser.js","sourceRoot":"","sources":["../../src/parser.tsx"],"names":[],"mappings":"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","sourcesContent":["import { RendererLike } from '@connectv/html';\nimport { Token, InlineLexer, TextRenderer, Slugger, TokensList } from 'marked';\n\nimport { PartialOptions, Options } from './options';\nimport { InlineProcessor } from './inline';\nimport { fill } from './defaults';\nimport { unescape } from './util/unescape';\n\n\nexport class Parser<R=unknown, T=unknown> {\n  readonly options: Options<R, T>;\n\n  private tokens: Token[]  = [];\n  private token: Token;\n  private slugger = new Slugger();\n  private inline: InlineProcessor<R, T>;\n  private inlineText: InlineLexer;\n  private renderer: RendererLike<R, T>;\n\n  constructor(options?: PartialOptions<R, T>) {\n    this.options = fill(options || {}) as any;\n  }\n\n  parse(tokens: TokensList, renderer: RendererLike<R, T>) {\n    this.renderer = renderer;\n    this.inline = new InlineProcessor(tokens, renderer, this.options);\n    this.inlineText = new InlineLexer(tokens.links as any, {\n      renderer: new TextRenderer() as any\n    });\n\n    this.tokens = tokens.reverse();\n    const res = <fragment/>;\n    while(this.next())\n      renderer.render(this.tok()).on(res);\n\n    return res;\n  }\n\n  private next() {\n    const _next = this.tokens.pop();\n    if (_next) this.token = _next;\n    return _next;\n  }\n\n  private safeNext() {\n    const _next = this.next();\n    if (!_next) /* istanbul ignore next */throw new Error('Unexpected end of stream');\n    return _next;\n  }\n\n  private peek() {\n    return this.tokens[this.tokens.length - 1];\n  }\n\n  private parseText() {\n    let body = (this.token as any).text || '';\n\n    while(this.peek().type === 'text')/* istanbul ignore next */\n      body += '\\n' + (this.next() as any).text;\n\n    return this.inline.process(body);\n  }\n\n  private tok() {\n    const renderer = this.renderer;\n\n    switch(this.token.type) {\n      case 'space': return this.options.Space ? <this.options.Space/> : <fragment/>;\n      case 'hr': return <this.options.Hr/>;\n      case 'heading':\n        const slug = this.slugger.slug(unescape(this.inlineText.output(this.token.text)));\n        return <this.options.Heading depth={this.token.depth}\n              slug={slug}>{this.inline.process(this.token.text)}</this.options.Heading>;\n      case 'code':\n        return <this.options.Code lang={this.token.lang || ''}>{this.token.text}</this.options.Code>;\n      case 'table': {\n        const header = this.token.header.map((cell, i) => \n            <this.options.TableHeaderCell align={(this.token as any).align[i]}>\n              {this.inline.process(cell)}\n            </this.options.TableHeaderCell>);\n\n        const body = this.token.cells.map(row => \n          <this.options.TableRow>\n            {row.map((cell, j) => <this.options.TableCell align={(this.token as any).align[j]}>\n              {this.inline.process(cell)}\n            </this.options.TableCell>)}\n          </this.options.TableRow>);\n\n        return <this.options.Table header={header as any} body={body as any}/>;\n      }\n      case 'blockquote_start': {\n        const body = <fragment/>;\n        while (this.safeNext().type !== 'blockquote_end')\n          renderer.render(this.tok()).on(body);\n\n        return <this.options.BlockQuote>{body}</this.options.BlockQuote>;\n      }\n      case 'list_start': {\n        const body = <fragment/>;\n        const ordered = this.token.ordered;\n        while (this.safeNext().type !== 'list_end')\n          renderer.render(this.tok()).on(body);\n\n        return <this.options.List ordered={ordered}>{body}</this.options.List>;\n      }\n      case 'list_item_start': {\n        const body = <fragment/>;\n        const loose = (this.token as any).loose;\n        while (this.safeNext().type !== 'list_item_end') {\n          if (!loose && (this.token.type as any) === 'text')\n            renderer.render(<fragment>{this.parseText()}</fragment>).on(body);\n          else\n            renderer.render(this.tok()).on(body);\n        }\n\n        return <this.options.ListItem>{body}</this.options.ListItem>;\n      }\n      case 'html':\n        return <this.options.Html content={this.token.text}/>\n      case 'paragraph':\n        return <this.options.Paragraph>{this.inline.process(this.token.text)}</this.options.Paragraph>;\n      case 'text':\n        return <this.options.Paragraph>{this.parseText()}</this.options.Paragraph>\n      default:/* istanbul ignore next */\n        throw new Error('Unrecognized Token:: ' + this.token.type);\n    }\n  }\n}\n"]}