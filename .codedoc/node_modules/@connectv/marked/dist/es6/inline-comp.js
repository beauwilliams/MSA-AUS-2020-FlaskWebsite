const compRegex = /^\[\:(\w+)(\s+(?:\w+\s*\=[^\,]+\s*)(?:\,\s*\w+\s*\=[^\,]+\s*)*)?\s*\]/;
export class InlineCompProcessor {
    constructor(renderer, map) {
        this.renderer = renderer;
        this.map = map;
    }
    process(el) {
        this.markers(el).forEach(marker => {
            let Comp = this.map[marker.component];
            if (!Comp)
                throw new Error('Unrecognized Inline Component:: ' + marker.component);
            const content = [];
            marker.$.childNodes.forEach(child => content.push(child));
            this.renderer.render(this.renderer.create(Comp, marker.props, content)).before(marker.$);
            marker.$.remove();
        });
        return el;
    }
    markers(el) {
        const markers = [];
        el.querySelectorAll('em').forEach(em$ => {
            var _a;
            let match;
            if (em$.firstChild && em$.firstChild instanceof Text
                && (match = compRegex.exec(em$.firstChild.textContent || ''))) {
                em$.firstChild.textContent = ((_a = em$.firstChild.textContent) === null || _a === void 0 ? void 0 : _a.substr(match[0].length)) || '';
                markers.push({
                    $: em$,
                    component: match[1],
                    props: this.props(match[2]),
                });
            }
        });
        return markers;
    }
    props(desc) {
        return (desc === null || desc === void 0 ? void 0 : desc.trim().split(',').reduce((props, bit) => {
            const [key, val] = bit.split('=').map(_ => _.trim());
            props[key] = val;
            return props;
        }, {})) || {};
    }
}
//# sourceMappingURL=inline-comp.js.map