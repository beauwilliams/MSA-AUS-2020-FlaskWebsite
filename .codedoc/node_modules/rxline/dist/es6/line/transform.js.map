{"version":3,"file":"transform.js","sourceRoot":"","sources":["../../../src/line/transform.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,UAAU,EAAE,IAAI,EAAE,EAAE,EAAE,UAAU,EAAE,MAAM,MAAM,CAAC;AACxD,OAAO,EAAE,SAAS,EAAE,MAAM,gBAAgB,CAAC;AAO3C,MAAM,OAAO,SAAS;IAGpB,YAAY,IAAoB;QAC9B,IAAI,CAAC,GAAG,GAAG,CAAC,CAAC,EAAE;YACb,IAAI;gBACF,MAAM,EAAE,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;gBACnB,IAAI,EAAE,YAAY,OAAO;oBAAE,OAAO,IAAI,CAAC,EAAE,CAAC,CAAC;qBACtC,IAAI,EAAE,YAAY,UAAU;oBAAE,OAAO,EAAE,CAAC;;oBACxC,OAAO,EAAE,CAAC,EAAE,CAAC,CAAC;aACpB;YAAC,OAAM,GAAG,EAAE;gBACX,OAAO,UAAU,CAAC,GAAG,CAAC,CAAC;aACxB;QACH,CAAC,CAAC;IACJ,CAAC;IAED,OAAO,CAAI,SAA2C;QACpD,IAAI,SAAS,YAAY,SAAS;YAChC,OAAO,IAAI,SAAS,CAAC,CAAC,CAAI,EAAE,EAAE,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;;YACxE,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,SAAS,CAAO,SAAS,CAAC,CAAC,CAAC;IAC3D,CAAC;IAED,KAAK,CAAC,CAAI,IAAI,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;CACpC;AAGD,MAAM,UAAU,QAAQ,KAAQ,OAAO,IAAI,SAAS,CAAC,CAAC,CAAI,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpE,MAAM,UAAU,SAAS,CAAO,IAAoB,IAAI,OAAO,IAAI,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC","sourcesContent":["import { Observable, from, of, throwError } from 'rxjs';\nimport { concatMap } from 'rxjs/operators';\n\n\nexport type Function<I, O> = (i: I) => O | Promise<O> | Observable<O>;\nexport type Function$<I, O> = (i: I) => Observable<O>;\n\n\nexport class Transform<I, O> {\n  readonly op$: Function$<I, O>;\n\n  constructor(_op$: Function<I, O>) { \n    this.op$ = i => {\n      try {\n        const _o = _op$(i);\n        if (_o instanceof Promise) return from(_o);\n        else if (_o instanceof Observable) return _o;\n        else return of(_o);\n      } catch(err) {\n        return throwError(err);\n      }\n    };\n  }\n\n  combine<X>(transform: Transform<O, X> | Function<O, X>): Transform<I, X> {\n    if (transform instanceof Transform)\n      return new Transform((i: I) => this.op$(i).pipe(concatMap(transform.op$)));\n    else return this.combine(new Transform<O, X>(transform));\n  }\n\n  apply(i: I) { return this.op$(i); }\n}\n\n\nexport function identity<I>() { return new Transform((i: I) => i); }\nexport function transform<I, O>(func: Function<I, O>) { return new Transform(func); }\n"]}