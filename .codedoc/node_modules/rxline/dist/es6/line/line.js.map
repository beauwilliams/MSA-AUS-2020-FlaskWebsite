{"version":3,"file":"line.js","sourceRoot":"","sources":["../../../src/line/line.ts"],"names":[],"mappings":"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","sourcesContent":["import { Observable, from, Subscription } from 'rxjs';\nimport { flatMap, toArray } from 'rxjs/operators';\n\nimport { Modifier } from './modifier';\nimport { Transform, Function, identity } from './transform';\nimport { ProcessingStrategy, sequentially } from './process';\nimport { tap } from './tap';\nimport { filter } from './filter';\n\n\nexport type LineContent<I> = Observable<I> | Promise<I[]> | I[];\nexport type SimpleLine<I> = Line<I, I>;\nexport type Pipeable<I, O, X> = Function<O, X> | Transform<O, X> | Modifier<I, O, I, X>;\n\n\nexport class Line<I, O> {\n  readonly content$: Observable<I>;\n\n  constructor(content: LineContent<I>, private transform: Transform<I, O>) {\n    if (content instanceof Observable) this.content$ = content;\n    else if (content instanceof Promise) this.content$ = from(content).pipe(flatMap(from));\n    else this.content$ = from(content);\n  }\n\n  pipe<X>(thing: Pipeable<I, O, X>): Line<I, X>;\n  pipe<A, X>(a: Pipeable<I, O, A>, x: Pipeable<I, A, X>): Line<I, X>;\n  pipe<A, B, X>(a: Pipeable<I, O, A>, b: Pipeable<I, A, B>, x: Pipeable<I, B, X>): Line<I, X>;\n  pipe<A, B, C, X>(a: Pipeable<I, O, A>, b: Pipeable<I, A, B>, c: Pipeable<I, B, C>, x: Pipeable<I, C, X>): Line<I, X>;\n  pipe<A, B, C, D, X>(a: Pipeable<I, O, A>, b: Pipeable<I, A, B>, c: Pipeable<I, B, C>, d: Pipeable<I, C, D>, x: Pipeable<I, D, X>): Line<I, X>;\n  pipe<A, B, C, D, E, X>(a: Pipeable<I, O, A>, b: Pipeable<I, A, B>, c: Pipeable<I, B, C>, d: Pipeable<I, C, D>, e: Pipeable<I, D, E>, x: Pipeable<I, E, X>): Line<I, X>;\n  pipe<A, B, C, D, E, F, X>(a: Pipeable<I, O, A>, b: Pipeable<I, A, B>, c: Pipeable<I, B, C>, d: Pipeable<I, C, D>, e: Pipeable<I, D, E>, f: Pipeable<I, E, F>, x: Pipeable<I, F, X>): Line<I, X>;\n  pipe<A, B, C, D, E, F, G, X>(a: Pipeable<I, O, A>, b: Pipeable<I, A, B>, c: Pipeable<I, B, C>, d: Pipeable<I, C, D>, e: Pipeable<I, D, E>, f: Pipeable<I, E, F>, g: Pipeable<I, F, G>, x: Pipeable<I, G, X>): Line<I, X>;\n  pipe<A, B, C, D, E, F, G, H, X>(a: Pipeable<I, O, A>, b: Pipeable<I, A, B>, c: Pipeable<I, B, C>, d: Pipeable<I, C, D>, e: Pipeable<I, D, E>, f: Pipeable<I, E, F>, g: Pipeable<I, F, G>, h: Pipeable<I, G, H>, x: Pipeable<I, H, X>): Line<I, X>;\n  pipe<A, B, C, D, E, F, G, H, J, X>(a: Pipeable<I, O, A>, b: Pipeable<I, A, B>, c: Pipeable<I, B, C>, d: Pipeable<I, C, D>, e: Pipeable<I, D, E>, f: Pipeable<I, E, F>, g: Pipeable<I, F, G>, h: Pipeable<I, G, H>, i: Pipeable<I, H, J>, x: Pipeable<I, J, X>): Line<I, X>;\n  pipe(...pipes: Pipeable<I, any, any>[]) {\n    return pipes.reduce((line, pipe) => line._pipe(pipe), this as Line<I, any>);\n  }\n\n  private _pipe<X>(thing: Pipeable<I, O, X>): Line<I, X> {\n    if (thing instanceof Transform)\n      return new Line(this.content$, this.transform.combine(thing));\n    else if (thing instanceof Modifier)\n      return new Line(this.content$, thing.modify(this.transform));\n    else\n      return new Line(this.content$, this.transform.combine(new Transform(thing)));\n  }\n\n  pick(func: Function<O, boolean>): Line<I, O> { return this.pipe(filter(func)); }\n  drop(func: Function<O, boolean>): Line<I, O> { return this.pipe(filter(async f => !await func(f))); }\n  peek(func: Function<O, unknown>): Line<I, O> { return this.pipe(tap(func)); }\n  funnel<T>(func: (l: Line<I, O>) => T): T { return func(this); }\n\n  process(strategy: ProcessingStrategy<I, O> = sequentially): SimpleLine<O> {\n    return new Line(new Promise((next, error) => {\n      strategy(this.content$, this.transform).pipe(toArray()).subscribe({next, error});\n    }), identity<O>());\n  }\n\n  prep(strategy: ProcessingStrategy<I, O> = sequentially): SimpleLine<O> {\n    return new Line(strategy(this.content$, this.transform), identity<O>());\n  }\n\n  collect(collector: Function<O[], unknown>): Subscription;\n  collect(\n    strategy: ProcessingStrategy<I, O>,\n    collector: Function<O[], unknown>,\n    handler?: (error: any) => void,\n  ): Subscription;\n  collect(collectorOrStrategy: Function<O[], unknown> | ProcessingStrategy<I, O>, \n          collector?: Function<O[], unknown>,\n          handler?: (error: any) => void) {\n    const strategy = collector ? collectorOrStrategy as ProcessingStrategy<I, O> : sequentially;\n    return this.prep(strategy).content$\n      .pipe(toArray())\n      .subscribe(collector || (collectorOrStrategy as Function<O[], unknown>), handler);\n  }\n}\n\n\nexport function line<I>(content: LineContent<I>): SimpleLine<I> { return new Line<I, I>(content, identity<I>()); }\n"]}