import { Observable, Subscription } from 'rxjs';
import { Modifier } from './modifier';
import { Transform, Function } from './transform';
import { ProcessingStrategy } from './process';
export declare type LineContent<I> = Observable<I> | Promise<I[]> | I[];
export declare type SimpleLine<I> = Line<I, I>;
export declare type Pipeable<I, O, X> = Function<O, X> | Transform<O, X> | Modifier<I, O, I, X>;
export declare class Line<I, O> {
    private transform;
    readonly content$: Observable<I>;
    constructor(content: LineContent<I>, transform: Transform<I, O>);
    pipe<X>(thing: Pipeable<I, O, X>): Line<I, X>;
    pipe<A, X>(a: Pipeable<I, O, A>, x: Pipeable<I, A, X>): Line<I, X>;
    pipe<A, B, X>(a: Pipeable<I, O, A>, b: Pipeable<I, A, B>, x: Pipeable<I, B, X>): Line<I, X>;
    pipe<A, B, C, X>(a: Pipeable<I, O, A>, b: Pipeable<I, A, B>, c: Pipeable<I, B, C>, x: Pipeable<I, C, X>): Line<I, X>;
    pipe<A, B, C, D, X>(a: Pipeable<I, O, A>, b: Pipeable<I, A, B>, c: Pipeable<I, B, C>, d: Pipeable<I, C, D>, x: Pipeable<I, D, X>): Line<I, X>;
    pipe<A, B, C, D, E, X>(a: Pipeable<I, O, A>, b: Pipeable<I, A, B>, c: Pipeable<I, B, C>, d: Pipeable<I, C, D>, e: Pipeable<I, D, E>, x: Pipeable<I, E, X>): Line<I, X>;
    pipe<A, B, C, D, E, F, X>(a: Pipeable<I, O, A>, b: Pipeable<I, A, B>, c: Pipeable<I, B, C>, d: Pipeable<I, C, D>, e: Pipeable<I, D, E>, f: Pipeable<I, E, F>, x: Pipeable<I, F, X>): Line<I, X>;
    pipe<A, B, C, D, E, F, G, X>(a: Pipeable<I, O, A>, b: Pipeable<I, A, B>, c: Pipeable<I, B, C>, d: Pipeable<I, C, D>, e: Pipeable<I, D, E>, f: Pipeable<I, E, F>, g: Pipeable<I, F, G>, x: Pipeable<I, G, X>): Line<I, X>;
    pipe<A, B, C, D, E, F, G, H, X>(a: Pipeable<I, O, A>, b: Pipeable<I, A, B>, c: Pipeable<I, B, C>, d: Pipeable<I, C, D>, e: Pipeable<I, D, E>, f: Pipeable<I, E, F>, g: Pipeable<I, F, G>, h: Pipeable<I, G, H>, x: Pipeable<I, H, X>): Line<I, X>;
    pipe<A, B, C, D, E, F, G, H, J, X>(a: Pipeable<I, O, A>, b: Pipeable<I, A, B>, c: Pipeable<I, B, C>, d: Pipeable<I, C, D>, e: Pipeable<I, D, E>, f: Pipeable<I, E, F>, g: Pipeable<I, F, G>, h: Pipeable<I, G, H>, i: Pipeable<I, H, J>, x: Pipeable<I, J, X>): Line<I, X>;
    private _pipe;
    pick(func: Function<O, boolean>): Line<I, O>;
    drop(func: Function<O, boolean>): Line<I, O>;
    peek(func: Function<O, unknown>): Line<I, O>;
    funnel<T>(func: (l: Line<I, O>) => T): T;
    process(strategy?: ProcessingStrategy<I, O>): SimpleLine<O>;
    prep(strategy?: ProcessingStrategy<I, O>): SimpleLine<O>;
    collect(collector: Function<O[], unknown>): Subscription;
    collect(strategy: ProcessingStrategy<I, O>, collector: Function<O[], unknown>, handler?: (error: any) => void): Subscription;
}
export declare function line<I>(content: LineContent<I>): SimpleLine<I>;
